---
layout: post
title: "Always define an else clause for portability #ifdefs"
date: 2010-04-22 09:51:00 -0400
categories: portability
julipedia: 2010/04/always-define-else-clause-for.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
If you use <tt>#ifdef</tt> conditionals in your code to check for portability features, be sure to always define a catch-all else clause that actually does something, even if this something is to error out.<br /><br />Consider the following code snippet, quoted from gamin's <tt>tests/testing.c</tt> file:<pre>if (arg != NULL) {<br />#ifdef HAVE_SETENV<br />  setenv("GAM_CLIENT_ID", arg, 1);<br />#elif HAVE_PUTENV<br />  char *client_id = malloc (strlen (arg) + sizeof "GAM_CLIENT_ID=");<br />  if (client_id)<br />  {<br />      strcpy (client_id, "GAM_CLIENT_ID=");<br />      strcat (client_id, arg);<br />      putenv (client_id);<br />  }<br />#endif /* HAVE_SETENV */<br />}<br />ret = FAMOpen(&amp;(testState.fc));</pre>The <tt>FAMOpen</tt> method queries the <tt>GAM_CLIENT_ID</tt> environment variable to set up the connections parameters to the FAM server. If the variable is not defined, the connection will still work, even though it will use some default internal value. In the test code above, the variable is explicitly set to let the tests use a separate server instance.<br /><br />Now, did you notice that we have to conditional branches? One for <tt>setenv</tt> and one for <tt>putenv</tt>? It seems reasonable to assume that one or the other must be present on any Unix system. Unfortunately, this is flawed:<br /><ul><li>What happens if the code forgets to include <tt>config.h</tt>?</li><li>What happens if the configure script fails to detect <i>both</i> <tt>setenv</tt> and <tt>putenv</tt>? This is not that uncommon, given how some configure scripts are written.</li><li>What happens if neither <tt>setenv</tt> nor <tt>putenv</tt> are available?<br /></li></ul>The answer to the three questions is: in the above code snippet, the code <tt>builds just fine</tt> but will misbehave at run time: neither <tt>HAVE_SETENV</tt> nor <tt>HAVE_PUTENV</tt> are defined, so the code will not be able to define the required environment variable. However, <tt>FAMOpen</tt> will later be called and it will not behave as expected because the variable has not been set.<br /><br />Note that this code snippet is just an example. I have seen many more instances of this exact same problem with worse consequences than the above.  Read: they were not part of the test code, but just part of the regular code path.<br /><br />So how do you implement the above in a saner way? You have two alternatives:<br /><ul><li>Add an <tt>#else</tt> clause that contains a fallback implementation. In the case above, we could, for example, prefer to use <tt>setenv</tt> if present because it has a nicer interface, and fall back to <tt>putenv</tt> if not found.<br />This has a disadvantage though: if you forget to include <tt>config.h</tt> or the configure script cannot correctly detect one of the possible implementations (even when present), you will always use the fallback implementation.</li><li>Keep each possible implementation correctly protected by a conditional, but add a <tt>#else</tt> clause that raises an error at <i>build time</i>. This will make sure that you never forget to define at least one of the portability macros for any reason. This is the preferred approach.</li></ul>Following the second suggestion above, the code would get the following structure: <pre>#if defined(HAVE_SETENV)<br />setenv(...);<br />#elif defined(HAVE_PUTENV)<br />putenv(...);<br />#else<br />#   error "Don't know how to set environment variables."<br />#endif</pre>With this code, we can be sure that the code will not build if none of the possible implementations are selected. We can later proceed to investigate why that happened.
