---
layout: post
title: "Boost: Shared pointers"
date: 2005-02-23 05:41:00 -0500
categories:
julipedia: 2005/02/boost-shared-pointers.html
excerpt_separator: </p>
---
<p>The <a href="http://www.boost.org/libs/smart_ptr/smart_ptr.htm">Boost Smart Pointers</a> library provides a set of classes to manage pointers.  I've started using <tt><a href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</a></tt> and am very happy with the results.  Let's see what it is.</p>  <p><tt>shared_ptr</tt> is a simple templated class that holds a pointer to a dynamically allocated object, which is reference counted. The object it references is automatically destroyed when the last instance of the smart pointer is removed; this usually happens when it gets out of its code scope.</p>  <p>So the first and most useful application of this class is to remove (almost) all possible memory leaks from your code. You do not need to issue explicit calls to the <tt>delete</tt> operator any more, since the smart class destructor will do it for you. In other words: you get a cheap garbage collector in your code which requires no external functionality and which has a very small performance penalty.</p>  <p>Another use of it (and this is the main reason why I started using this class) is to make some interfaces (function prototypes) easier to understand. Consider the following class structure (coming from <a href="http://vcsme.sourceforge.net/">VCS Made Easy</a>:</p>  <pre>struct entity { ... }<br />struct tree : public entity { ... }<br />struct group : public entity {<br />   void add_entity(entity* e);<br />   ...<br />}</pre><p></p>  <p><tt>group</tt> is an <tt>entity</tt> container, as you can guess from its name and from its <tt>add_entity</tt> method.  Note that this method takes a pointer to an <tt>entity</tt> object. Now the doubt arises: does this pointer refer to a dynamically allocated object or to something else (i.e., on the stack)? That is: will the class take care to delete all objects it holds or will leave that task to the caller?</p>  <p>In my first implementation, the function was meant to take a dynamically allocated instance, because <tt>group's</tt> destroyer manually took care to delete all of its contents. This destructor could produce errors if the user inserted an stack object in the container, because <tt>delete</tt> could not be applicable.  Thus I had to stick a big comment near the function definition warning the user.</p>  <p>Using smart pointers, the interface becomes clearer, and there is no possibility to make the mistakes outlined above. The prototype becomes:</p>  <pre>void add_entity(boost::shared_ptr<entity> e);</entity></pre>  <p>It's now clear that the function takes a pointer to a dynamically allocated object (due to the nature of the smart pointers). Anyway, if it referred to a locally allocated object (I'm not sure if <tt>shared_ptr</tt> can do that), this could cause no problems because only the last instance deleted could cause the real object to be freed (no matter in which order the objects were destroyed). Plus we've also got ridden of <tt>group's</tt> destroyer!</p>  <p>Therefore, this is an easy way to make your code safer and clearer. Note that there are several other interesting smart pointers that you may want to look at, but I'll leave those to the documentation.</p><p class="mobile-post"></p>
