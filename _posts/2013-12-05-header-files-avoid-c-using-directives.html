---
layout: post
title: "Header files: Avoid C++ 'using' directives"
date: 2013-12-05 12:00:00 -0500
categories: c++ header-files
julipedia: 2013/12/header-files-avoid-c-using-directives.html
excerpt_separator: </p>
---
<p>Following up on the previous C++ post, here comes one more thing to consider when writing header files in this language.</p> <p><b><tt>using</tt> and <tt>using namespace</tt></b></p> <p>The C++ <tt>using</tt> directive and its more generic <tt>using namespace</tt> counterpart, allow the programmer to bring a given symbol or all the symbols in a namespace, respectively, into the calling scope.  This feature exists to simplify typing and, to some extent, to make the code more readable.  (It may have come into existence to simplify the porting of old, non-ISO C++ code to modern C++, but that's just a guess.)</p> <p>The most common use of these that I have seen is to slap a <tt>using namespace std;</tt> at the beginning of a source file so that all of the symbols in the standard library are available without having to prefix each one of them with <tt>std::</tt>.  So far so good.</p> <p>Another not-so-common practice is to rarely use this directive and, when using it, place it in the innermost scope where it is needed.  In particular, this can make a function much easier to digest:</p> <pre>int complex_computation(... inputs ...) {<br />    using my_long_namespace::and_another_one::compute_engine;<br /><br />    compute_engine ce(compute_engine::DO_MAGIC);<br />    const compute_engine::result r = ce.run(... inputs ...);<br />    return r.to_integer();<br />}</pre> <p>Imagine how this function would look like if you had to prefix every instance of <tt>compute_engine</tt> with <tt>my_long_namespace::and_another_one::</tt>!</p> <p><b>The rule</b></p> <p>To recap, <tt>using</tt> directives in implementation, <tt>cpp</tt> files, is perfectly fine.</p> <p>Now, what's wrong &mdash; really, really wrong &mdash; is to place a <tt>using</tt> directive <i>in a header file</i>.  These directives exist to be used at the source file level where the programmer has full control of all included headers and their possible conflicts.  If header files decide to import names within a namespace into, say, the global scope, it is highly likely that two header files collide.  Not to mention that doing so renders namespaces useless!</p> <p>So: keep all declarations in a header file well-contained into a namespace and do not ever expose those to the global scope with a <tt>using</tt> directive.  Even more: do not ever do this for namespaces you do not control, like <tt>std</tt>.</p> <p><b>The exception</b></p> <p>But I think there is a little exception, as usual.</p> <p>Sometimes, standard libraries from different vendors differ in what they expose via the C++-style headers for standard C functionality.  Take <tt>vsnprintf(3)</tt> as an example.  This function is declared in the <tt>stdio.h</tt> file in C and in the <tt>cstdio</tt> file in C++.  Using the latter should mean that the function is made available only in the <tt>std</tt> namespace, not globally... but that's not always the case.  Some standard libraries will expose <tt>vsnprintf(3)</tt> as a global symbol even when using <tt>cstdio</tt>.</p> <p>The question is: how do you use this function in your code?  Because, depending on the compiler, you will either have to prefix its call with <tt>std::</tt> or not.  You have two alternatives:</p> <table><tr><td><pre>// Option 1.<br /><br />#include &lt;cstdio&gt;<br />#if !defined(HAVE_STD_VSNPRINTF)<br />namespace std {<br />using ::vsnprintf;<br />}<br />#endif<br /><br />...<br /><br />    // Assume it is in std::<br />    std::vsnprintf(...);</pre></td><td><pre>// Option 2.<br /><br />#include &lt;cstdio&gt;<br />#if defined(HAVE_STD_VSNPRINTF)<br />using std::vsnprintf;<br />#endif<br /><br /><br /><br />...<br /><br />    // Assume it is in ::<br />    ::vsnprintf(...);</pre></td></tr></table> <p>These rely on you being able to define <tt>HAVE_STD_VSNPRINTF</tt> accordingly, which you can do with a manually-crafted <tt>autoconf</tt> test or with more complex magic that relies on compiler-defined constants.</p> <p>What happens when you have to use this function in many different header files, though?  Do you repeat this compatibility hack in all of the files you care about, or do you try to code reuse by putting it in a header file?  Obviously, the latter is better.  But if you do the latter, you really should go for option 1 because option 2 would violate the rule above pretty badly.</p> <p>Can you think of other exceptions?</p>
