---
layout: post
title: "SoC: Status report 2"
date: 2005-07-18 17:28:00 -0400
categories:
julipedia: 2005/07/soc-status-report-2.html
excerpt_separator: </p>
---
<p>After several days since the <a href="http://www.livejournal.com/users/jmmv/37705.html">previous status report</a>, it's time for a new one. During the past week, I've improved several aspects of the existing code, without adding many new stuff.</p>  <p>First of all, I added several other VFS hooks needed to avoid crashes due to null pointers and completed the code up to the point where the file system can be mounted and unmounted (the latter was more difficult than I thought).</p>  <p>Then I also added code to manage the root node of the file system so that that information can be used where needed and completed the <tt>statvfs</tt> hook. This required the addition of multiple configurable parameters (ownership, size of the filesystem, etc.) into the mount arguments structure, which resulted in many different changes in the <tt>mount_tmpfs(8)</tt> utility.  I feel some of the code implemented in this utility could go into <tt>libutil</tt>, but I won't touch that (yet) ;-)</p>  <p>Furthermore, and as the code is starting to be "usable", I added some regression tests following the existing structure in <a href="http://www.netbsd.org/">NetBSD</a>.  I guess they will need to be refactored soon because of the <a href="http://netbsd-soc.sourceforge.net/projects/regress/">regress</a> NetBSD-SoC project, but they do the job for now.  The <a href="http://netbsd-soc.sourceforge.net/projects/tmpfs/">project's page</a> explains how to run them.</p>  <p>At last, I've read a bit about UVM and memory management to see how to allocate unwired memory blocks. I still don't know yet how that works, so I've tried to organize the code to minimize the amount of changes needed when I learn the correct way to do it (i.e., I'm using <tt>malloc</tt>/<tt>free</tt> now to request a single memory block).</p>  <p>The next step is to design how to organize the file data and meta data into the memory region allocated for the file system. This is the same problem as the design of an on-disk file system, although it's simpler: several details can be omitted, such as redundancy or data placement (well, this last point is questionable, since "fragmentation" can cause more cache/page faults than expected). Doing this is a must now, because it is needed to implement vnode operations.</p><p class="mobile-post"></p>
