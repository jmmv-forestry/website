---
layout: post
title: "Flattening an array of arrays"
date: 2007-06-07 17:44:00 -0400
categories: array haskell perl
julipedia: 2007/06/flattening-array-of-arrays.html
excerpt_separator: </p>
---
This evening <a href="http://blogs.nopcode.org/brainstorm/">a friend</a> asked me if I knew how to easily flatten an <span style="font-style: italic;">array of arrays</span> (<span class="blsp-spelling-error" id="SPELLING_ERROR_0">AoA</span> from now on) in Perl 5.  What that means is, basically, to construct a single array that contains the concatenation of all the arrays inside the <span class="blsp-spelling-error" id="SPELLING_ERROR_1">AoA</span>.<br /><br />My first answer was: "<tt><span class="blsp-spelling-error" id="SPELLING_ERROR_2">foldr</span></tt>", but I knew beforehand that he wouldn't like it because... this is <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>.  After some time we got to the conclusion that there is no trivial way to flatten an <span class="blsp-spelling-error" id="SPELLING_ERROR_3">AoA</span> in Perl 5, even though Perl 6 includes a built-in function to do so.  He ended up using this code to resolve the problem:<br /><br /><tt>my @ordered = map { @$_ } values %arches;</tt><br /><br /><span class="blsp-spelling-error" id="SPELLING_ERROR_4">Ew</span>, how ugly.  Anyway, as part of the discussion, I then continued on my first answer just to show him how versatile functional programming is.  And I said, hey, look at this nice example:<br /><br /><tt>Hugs> <span class="blsp-spelling-error" id="SPELLING_ERROR_5">foldr</span> (++) [] [[1,2], [3,4]]<br /><br />[1,2,3,4]</tt><br /><br />His answer: oh well, but it is easier in Ruby: just use the built-in <tt><span class="blsp-spelling-error" id="SPELLING_ERROR_6">ary</span>.flatten</tt> function.  <span class="blsp-spelling-error" id="SPELLING_ERROR_7">Hmm</span>... but why would I need a built-in function in Haskell when I can just redefine it in a trivial single line?<br /><br /><tt>flatten = <span class="blsp-spelling-error" id="SPELLING_ERROR_8">foldr</span> (++) []</tt><br /><br />There you go, you can now flatten as much <span class="blsp-spelling-error" id="SPELLING_ERROR_9">AoAs</span> as you want!  (Huh, no parameters?  Well, you don't need to name them.)  Isn't functional programming great? ;-)<br /><br />PS: I know nothing about Ruby, but I bet you can write a very similar definition using this or other non-functional languages.  I remember someone explaining somewhere (yeah, that's very specific) that Ruby has some patterns that resemble functional programming.  So yes, you can probably define a flatten function by using something that looks like <tt><span class="blsp-spelling-error" id="SPELLING_ERROR_10">foldr</span></tt>, but that might look out of place in an imperative language. (Would be great to know about it for sure!)<br /><br /><b>Edit (June 9th)</b>: Added a link to my friend's blog.
