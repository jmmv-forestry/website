---
layout: post
title: "Using va_copy to safely pass ap arguments around"
date: 2011-09-12 22:34:00 -0400
categories: c portability
julipedia: 2011/09/using-vacopy-to-safely-pass-ap.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
<p><b>Update (2014-12-19)</b>: The advice provided in this blog post is questionable and, in fact, probably incorrect.  The bug described below must have happened for some unrelated reason (like, maybe, reuse of <tt>ap</tt>), but at this point (three years later!) I do not really remember what was going on here nor have much interest in retrying.</p>A long time ago, while I was preparing an ATF release, I faced many failing tests and crashes in one of the platforms under test. My memory told me this was a problem in OpenSolaris, but the <a href="http://www.blogger.com/mtn-host.prjek.net/viewmtn/atf/revision/info/655c6c51f2155076f482a038042c67fd25adc934">repository logs</a> say that the problem really happened in Fedora 8 x86_64.<br />The problem manifested itself as segmentation faults pretty much everywhere, and I could trace such crashes down to pieces of code like the following, of which the C code of ATF is full of:<br /><pre>void<br />foo_fmt(const char *fmt, ...)<br />{<br />    va_list ap;<br /><br />    va_start(ap, fmt);<br />    foo_ap(fmt, ap);<br />    va_end(ap);<br />}<br /><br />void<br />foo_ap(const char *fmt, va_list ap)<br />{<br />    char buf[128];<br /><br />    vsnprintf(buf, sizeof(buf), fmt, ap);<br /><br />    ... now, do something with buf ...<br />}</pre>The codebase of ATF provides <tt>_fmt</tt> and <tt>_ap</tt> variants for many functions to give more flexibility to the caller and, as shown above, the <tt>_fmt</tt> variant just relies on the <tt>_ap</tt> variant to do the real work.<br />Now, the crashes that appeared from the code above seemed to come from the call that consumes the <tt>ap</tt> argument, which in this case is <tt>vsnprintf</tt>. Interestingly, though, all the tests in other platforms but Linux x86_64 worked just fine, and this included OpenSolaris, other Linux distributions, some BSDs and even different hardware platforms.<br />As it turned out, you <b>cannot blindly pass <tt>ap</tt> arguments around</b> because they are not "normal" parameters (even though, unfortunately, they look like so!). In most platforms, the <tt>ap</tt> element will be just an "absolute" pointer to the stack, so passing the variable to an inner function calls is fine because the caller's stack has not been destroyed yet and, therefore, the pointer is still valid. But... the <tt>ap</tt> argument can have other representations. It'd be an offset to the stack instead of a pointer, or it'd be a data structure that holds all the variable parameters. If, for example, the <tt>ap</tt> argument held an offset, passing it to an inner function call would make such offset point to "garbage" because the stack would have been grown due to the new call frame. (I haven't investigated what specific representation is x86_64 using.)<br />The solution is to use the <tt>va_copy</tt> function to generate a new <tt>ap</tt> object that is valid for the current stack frame. This is easy, so as an example, we have to rewrite the <tt>foo_ap</tt> function above as follows:<br /><pre>void<br />foo_ap(const char *fmt, va_list ap)<br />{<br />    char buf[128];<br />    va_list ap2;<br /><br />    va_copy(ap2, ap);<br />    vsnprintf(buf, sizeof(buf), fmt, ap2);<br />    va_end(ap2);<br /><br />    ... now, do something with buf ...<br />}</pre>This duplication of the <tt>ap</tt> argument pointing to the variable list of arguments ensures that <tt>ap2</tt> can be safely used from the new stack frame.
