---
layout: post
title: "A split function in Haskell"
date: 2006-08-24 05:09:00 -0400
categories: haskell
julipedia: 2006/08/split-function-in-haskell.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
Splitting a string into parts based on a token delimiter is a very common operation in some problem domains.  Languages such as Perl or Java provide a <tt>split</tt> function in their standard library to execute this algorithm, yet I'm often surprised to see how many languages do not have one.  As far as I can tell neither C++ nor Haskell have it so I have coded such a function in the past multiple times in both languages.  (This is not exactly true: Haskell has the <tt>words</tt> function which splits a string by whitespace characters.  Nevertheless I didn't know this when I wrote my custom implementation.)<br /><br />When I implemented a custom <tt>split</tt> function in Haskell I was really amazed to see how easy and clean the resulting code was.  I'm sure there is some better and even cleaner way to write it because I'm still a Haskell newbie!  Here is it:<pre>split :: String -> Char -> [String]<br />split [] delim = [""]<br />split (c:cs) delim<br />   | c == delim = "" : rest<br />   | otherwise = (c : head rest) : tail rest<br />   where<br />       rest = split cs delim</pre>The above code starts by declaring the function's type; this is <i>optional</i> because Haskell's type system is able to <i>automatically deduce it</i>.  It then uses pattern matching to specify the algorithm's base and recursive cases.  At last, the recursive case is defined by parts, just as you do in mathematics.  Oh, and why recursivity?  Because iteration does not exist in functional programming in the well-known sense of imperative languages.  Also note the lack of variables (except for the input ones) and that everything is an evaluable <i>expression</i>.<br /><br />Let's now compare the above code with two implementations in C++.  A first approach to the problem following common imperative programming thinking results in an iterative algorithm:<pre>std::deque&lt; std::string &gt;<br />split_iterative(const std::string& str, char delim)<br />{<br />   std::deque&lt; std::string &gt; parts;<br /><br />   std::string word;<br />   for (std::string::const_iterator iter = str.begin();<br />        iter != str.end(); iter++) {<br />       if (*iter == delim) {<br />           parts.push_back(word);<br />           word.clear();<br />       } else<br />           word += *iter;<br />   }<br />   parts.push_back(word);<br /><br />   return parts;<br />}</pre>This is certainly uglier and much more difficult to prove right; iteration is a complex concept in that sense.  In this code we have variables that act as acumulators, temporary objects, commands, etc.  Be glad that I used C++ and not C to take advantage of STL containers.<br /><br />OK, to be fair the code should be implemented in a recursive way to be really comparable to the Haskell sample function.  Let's attempt it:<pre>std::deque&lt; std::string &gt;<br />split_recursive(const std::string& str, char delim)<br />{<br />   std::deque&lt; std::string &gt; parts;<br /><br />   if (!str.empty()) {<br />       std::string str2 = str;<br />       parts = split_recursive(str2.erase(0, 1), delim);<br /><br />       if (str[0] == delim)<br />           parts.push_front("");<br />       else<br />           parts[0] = str[0] + parts[0];<br />   } else<br />       parts.push_front("");<br /><br />   return parts;<br />}</pre>This <tt>split_recursive</tt> function follows the same algorithm as the <tt>split</tt> written in Haskell.  I find that it is still harder to read and more delicate (I had some segmentation fault s until I got it right).<br /><br />Of course Haskell is not appropriate for everything (which is true for <i>every</i> language out there).  I have yet to write a big and useful program in Haskell to really see its power and to be able to relly compare it to other languages.  All I can do at the moment is to compare trivial stuff as the above.
