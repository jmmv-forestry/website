---
layout: post
title: "Linker's link sets"
date: 2005-09-18 08:19:00 -0400
categories:
julipedia: 2005/09/linkers-link-sets.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
<p>I don't know about other linkers, but GNU ld provides a very useful feature: <i>link sets</i>.  A link set is a list of symbols constructed during <i>link time</i> which can then be inspected in regular code. This is very interesting in situations when you want to initialize several subsystems from a centralized place but don't know which of these will be available; that is, you don't know which ones will be in the final binary.</p>  <p>To illustrate this feature, let's see how NetBSD manages file system initialization. In NetBSD, you can configure which file systems you want in your kernel binary and which not. Each file system has a <tt>vfs_init</tt> hook that must be called during system initialization but... how to do this in a clean and extensible way? For a moment, imagine we didn't have link sets. In this case, NetBSD would need a function similar to the following:</p>  <pre>void<br />init_file_systems(void)<br />{<br />#ifdef UFS<br />   ufs_init();<br />#endif <p>#ifdef MSDOSFS<br />   msdosfs_init();<br />#endif </p><p>...</p>#ifdef TMPFS<br />   tmpfs_init();<br />#endif<br />}</pre><p></p>  <p>Isn't this ugly? Very much, although one might support the visual ugliness. However, the real problem is that, in order to add a new file system, you need to edit other parts of the system; this might seem acceptable in an open source project, but what if the initialization code was closed source? You couldn't add your file system. This clearly goes against extensibility.</p>  <p>Using link sets, this problem goes away: each independent module is able to add itself to a global list of symbols. Continuing our file systems example, take a look to the <tt>vfsinit</tt> function in <tt>kern/vfs_init.c</tt>.  The first thing you see there is the declaration (<tt>__link_set_decl</tt>) of a new link set, called <tt>vfsops</tt>, that will hold pointers to <tt>struct vfsops</tt> objects.  Then, the code uses the <tt>__link_set_foreach</tt> construction to iterate over the list, correctly initializing all the file systems.  The following is an extract of this, with <i>many</i> details removed:</p>  <pre>void<br />vfsinit(void)<br />{<br />   __link_set_decl(vfsops, struct vfsops);<br />   struct vfsops * const *vfsp;  /* Iterator */<br /><br />   __link_set_foreach(vfsp, vfsops) {<br />       (*vfsp)-&gt;vfs_init();<br />   }<br />}</pre><p></p>  <p>At last, how does a module add itself to the link set?  Using the <tt>__link_set_add_data</tt> operation, which takes the name of the link set as its first argument and the object to be added as the second one.  E.g.:</p>  <pre>struct vfsops barops = {<br />   ...<br />   ufs_init,<br />   ...<br />};<br />__link_set_add_data(vfsops, barops);</pre><p></p>  <p>As you can see, using link sets the kernel does not need to know at all which file systems are compiled into it, yet the initialization code will be executed.</p><p class="mobile-post"></p>
