---
layout: post
title: "Dependency injection: simple class constructors"
date: 2010-12-26 05:41:00 -0500
categories: testing
julipedia: 2010/12/dependency-injection-simple-class.html
excerpt_separator: </p>
---
Following my <a href="http://blog.julipedia.org/2010/12/dependency-injection-and-testing.html">previous post on dependency injection</a> (DI for short), I wanted to show you today another example of code in which DI helps in making the code clearer and easier to validate. In this case, the person to blame for the original piece of code being criticized is me.<br /><br />The <tt>atffile</tt> module in ATF provides a class to represent the contents of <tt>Atffile</tt>s. An <tt>Atffile</tt> is, basically, a file containing a list of test programs to run and a list of properties associated to these test programs. Let's consider the original implementation of this module:<pre>class atffile {<br />    strings_vector _test_programs;<br />    strings_vector _properties;<br /><br />public:<br />    atffile(const path& file)<br />    {<br />        std::ifstream input(file.c_str());<br />        _test_programs = ... parse list from input ...;<br />        _properties = ... parse list from input ...;<br />    }<br /><br />    ... getters and other read-only methods ...<br />};</pre>According to the object-oriented programming (OOP) principles we are taught over and over again, this seems like a reasonable design. An <tt>atffile</tt> object is entirely self-contained: if the constructor finishes successfully, we know that the new object matches exactly the representation of an <tt>Atffile</tt> on disk. The other methods in the class provide read-only access to the internal attributes, which ensures that the in-memory representation remains consistent.<br /><br />However, this design couples the initialization of an object with external dependencies, and that is bad for two main reasons: first, because it makes testing (very) difficult; and, second, because it makes an apparently simple action (constructing an object) a potentially expensive task (reading from an external resource).<br /><br />To illustrate the first point, let's consider a helper free-function that deals with an <tt>atffile</tt> object:<pre>std::string<br />get_property(const atffile& file, const std::string& name,<br />             const std::string& defvalue)<br />{<br />    const strings_vector& props = file.properties();<br />    const strings_vector::const_iterator iter =<br />        props.find(name);<br />    if (iter == props.end())<br />        return defvalue;<br />    else<br />        return *iter;<br />}</pre>Now, how do we write unit-tests for this function? Note that, to execute this function, we need to pass in an <tt>atffile</tt> object. And to instantiate an <tt>atffile</tt>, we need to be able to read a <tt>Atffile</tt> from disk because the only constructor for the <tt>atffile</tt> class has this dependency on an external subsystem. So, summarizing, to test this innocent function, we need to create a file on disk with valid contents, we need to instantiate an <tt>atffile</tt> object pointing to this file, and only then we can pass it to the <tt>get_property</tt> function. At this point, our unit test smells like an integration test, and it actually is for no real reason. This will cause our test suite to be more fragile (the test for this auxiliary function depends on the parsing of a file) and <i>slow</i>.<br /><br />How can we improve the situation? Easy: decoupling the dependencies on external systems from the object initialization. Take a look at this rewritten <tt>atffile</tt> class:<pre>class atffile {<br />    strings_vector _test_programs;<br />    strings_vector _properties;<br /><br />public:<br />    atffile(const strings_vector& test_programs_,<br />            const strings_vector& properties_) :<br />        _test_programs(test_programs_),<br />        _properties(properties_)<br />    {<br />        assert(!_test_programs.empty());<br />    }<br /><br />    static atffile<br />    parse(const path& file)<br />    {<br />        std::ifstream input(file.c_str());<br />        strings_vector test_programs_ =<br />            ... parse list from input ...;<br />        strings_vector properties_ =<br />            ... parse list from input ...;<br />        return atffile(test_programs_, properties_);<br />    }<br /><br />    ... getters and other read-only methods ...<br />};</pre>Note that this new design does <i>not</i> necessarily violate OOP principles: yes, we can now construct an object with fake values in it by passing them to the constructor, but that does not mean that such values can be inconsistent once the object is created. In this particular example, I have added an assertion in the constructor to reenforce a check performed by <tt>parse</tt> (that an <tt>atffile</tt> must list at least one test program).<br /><br />With this new design in mind, it is now trivial to test the <tt>get_property</tt> function shown above: constructing an auxiliary <tt>atffile</tt> object is easy, because we can <i>inject</i> values into the object to later pass it to <tt>get_property</tt>: no need to create a temporary file that has to be valid and later parsed by the <tt>atffile</tt> code. Our test now follows the true sense of a <i>unit</i> test, which is much faster, less fragile and "to-the-point". We can later write integration tests if we so desire. Additionally, we can also write tests for <tt>atffile</tt> member functions, and we can very easily reproduce corner cases for them by, for example, injecting bad data. The only place where we need to create temporary <tt>Atffile</tt>s is when we need to test the <tt>parse</tt> class method.<br /><br />So, to conclude: <b>make your class constructors as simple as possible</b> and, in particular, <b>do not make your class constructors depend on external systems</b>. If you find yourself opening resources or constructing other objects from within your constructor, you are doing it wrong (with very few exceptions).<br /><br />I have been using the above principle for the last ~2 years and the results are neat: I am much, much more confident on my code because I write lots of more accurate test cases and I can focalize dependencies on external resources on a small subset of functions. (Yes, <a href="http://code.google.com/p/kyua/">Kyua</a> uses this design pattern intensively!)
