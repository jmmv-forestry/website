---
layout: post
title: "Readability: Don't modify variables"
date: 2013-07-25 12:00:00 -0400
categories: readability
julipedia: 2013/07/readability-don-modify-variables.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
<p><a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment">Single assignment</a> says that a variable should only be assigned a value once; i.e. a variable should only be <em>initialized</em> and never modified later.  This could be said to be a property of functional programming —never mind that it's used in compiler optimization a damn lot— so it may sound a bit out of scope in a readability post.  Not really.</p> <p>When you <i>force yourself to avoid modifying already-defined variables</i>, you will need to find other ways to express your intent.  To do so, in general: you will use a high-order construction instead of a loop; you will end up having to define intermediate variables, each with its own descriptive name; or you will move pieces of the code to an auxiliary function, also with a descriptive name.</p> <p>As a result, you will get clearer code: an identifier within a code block will be only used for a single purpose.  Once the reader has determined what the identifier is and what it refers to, he can hold onto that assumption for the whole code block.</p> <p>Let's take a look at the previously-described cases one by one.</p> <p><strong>Use high-order constructions instead of accumulators</strong></p> <p>High-order constructions, like list comprehensions, <tt>map</tt>s, <tt>reduce</tt>s, <tt>filter</tt>s, <tt>sum</tt>s, etc. are powerful constructs that can replace loops in many cases.  Use them to construct the value of a variable at once, instead of building it by accumulating values over a loop.</p> <p>In other words, given this code:</p> <pre>adults = []<br />for person in people:<br />    if person.age &gt;= 21:<br />        adults.append(person)</pre> <p>Change it to one of the following:</p> <pre>adults = [person for person in people if person.age &gt;= 21]</pre> <pre>adults = filter(lambda person: person.age &gt;= 21, people)</pre> <p>Reasoning over a loop is hard: loops can do "anything", so you must read the whole structure to understand what is going on and what the side-effects are.  On the other hand, these two one-liners show exactly what your intent is.  (Additionally, because these alternative idioms are at a higher semantic level, your compiler or runtime engine could do a much better job at optimizing &mdash;or, mind you, parallelizing&mdash; them.)  <p><strong>Break up long expressions into various intermediate values</strong></p> <p>Given this code:</p> <pre>people = load_people(file)<br />everybody_widget.update(people)<br /><br />people = [person for person in people if person.age &gt; 21]<br />adults_widget.update(people)<br /><br />people = [person for person in people if person.city == here]<br />nearby_widget.update(people)</pre> <p>You can see that the <tt>people</tt> variable has been assigned a value three times.  Each time, a new filter has been applied to construct the subsequent value.  Note that to understand what value of <tt>people</tt> might have at any point of the snippet, you must know what has happened up to that point. If you do this instead:</p> <pre>people = load_people(file)<br />everybody_widget.update(people)<br /><br />adults = [person for person in people if person.age &gt; 21]<br />adults_widget.update(adults)<br /><br />nearby_adults = [person for person in adults<br />                 if person.city == here]<br />nearby_widget.update(nearby_adults)</pre> <p>Then it's obvious what every variable holds from the point where they were defined to the end of the code block.  The names of the intermediate computations are clear, and the original variables always hold their initial values.</p> <p><strong>Move auxiliary computations to a separate function</strong></p> <p>This is a followup to the previous code snippet.  We could go one step further and rewrite it as follows:</> <pre>def FilterAdults(people);<br />    return [person for person in people if person.age &gt; 21]<br /><br />def FilterNearby(people):<br />    return [person for person in people if person.city == here]<br /><br />people = load_people(file)<br />everybody_widget.update(people)<br /><br />adults = FilterAdults(people)<br />adults_widget.update(adults)<br /><br />nearby_adults = FilterNearby(adults)<br />nearby_widget.update(nearby_adults)</pre> <p>This is my preferred alternative when the computation of the intermediate values is more complex than a single line (not the case above).  Note that by splitting every step into its own function, you give your code higher semantical meaning and, as a bonus point, you can unit-test the various components more easily.  Note also that you are <a href="http://julipedia.meroh.net/2013/06/readability-avoid-comments.html">avoiding any kind of comments</a> by making the code itself state what the various steps are.</p> <p>Let me conclude by saying that what is described in this post are not golden rules.  There will be cases where modifying an existing variable is the right thing to do, either because it's unavoidable or because it's just clearer that way.  But, if you stop for a moment to consider single assignments every time you write code, you will generally realize that there is a more expressive, self-documenting way to do the same thing.</p>
