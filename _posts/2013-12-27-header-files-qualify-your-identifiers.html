---
layout: post
title: "Header files: Qualify your identifiers"
date: 2013-12-27 13:00:00 -0500
categories: header-files
julipedia: 2013/12/header-files-qualify-your-identifiers.html
excerpt_separator: </p>
---
<p>Apologies for the long pause in the <a href="http://julipedia.meroh.net/search/label/header-files">header files series</a> and in blogging in general.  With the holidays in between and, especially, with my refreshed energy to do stuff in the FreeBSD and Kyua camps, I haven't had any reasonable amount of time to write.  And, sincerely, with my very limited free time I really cannot cover it all.  So... these days, coding it is thus expect a reduced blogging pace!</p> <hr /> <p>As we saw in the previous post, <a href="/2013/12/header-files-poor-mans-replacement-for.html">header files are a poor system to implement real modules</a>.  In particular, any identifier defined in a header file becomes "public" to any translation unit including such file.  This, of course, comes with implied dangers in name collisions and symbol redefinitions.</p> <p>There is no way to prevent this, so let's see some simple workarounds.</p> <p><b>C</b></p> <p>The only workaround you have in C is to fully qualify your identifiers with a prefix that hopefully is unique within any code that may require your headers.  In the general case, it is often good enough to just use your project name as the prefix: for example, for a project <tt>libfoo</tt>, you would use a <tt>foo_</tt> prefix in all of your identifiers.</p> <p>Avoid the temptation to shorten your project name to a single letter.  There are only so many letters in the alphabet so you &mdash;or, worse, the users of your code&mdash; are guaranteed to experience collisions with some other library at some point in the future.</p> <p>On the other hand, there is no real benefit to go to great extents like in Java where namespaces include a domain name that you control so as to enforce globally-unique names.  In fact, doing this in a language like C would result in a completely unusable API due to extremely-long identifier names.</p> <p><b>C++</b></p> <p>Things are slightly better in the C++ camp due to the existence of namespaces.  Installable header files should define <i>everything</i> they provide within a project-specific namespace.</p> <p>There is one caveat that many people seem to forget: <b>macros</b> (and other preprocessor symbols)!  Defining a macro within a namespace <i>does not make it specific to the namespace</i>.  Macros are "global" by default due to the fact that... well... they belong to a separate language and are processed separately (n.b. not the case in clang, but that's a separate story).  So, for macros, you will have to do the same as in C and prefix them explicitly with your project name.  It's ugly, so bonus points if you can avoid providing macros altogether.</p>
