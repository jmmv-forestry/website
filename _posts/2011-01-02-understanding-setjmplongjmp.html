---
layout: post
title: "Understanding setjmp/longjmp"
date: 2011-01-02 03:22:00 -0500
categories: c
julipedia: 2011/01/understanding-setjmplongjmp.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
For a long time, I have been aware of the existence of the standard C functions <tt>setjmp</tt> and <tt>longjmp</tt> and that they can be used to simulate exceptions in C code. However, it wasn't until yesterday that I had to use them... and it was not trivial. The documentation for these functions tends to be confusing, and understanding them required looking for additional documents and a bit of experimentation. Let's see if this post helps in clarifying how these functions work.<br /><br />The first call to <tt>setjmp</tt> causes the process state (stack, CPU registers, etc.) to be saved in the provided <tt>jmp_buf</tt> structure and, <i>then</i>, a value of 0 to be returned. A subsequent call to <tt>longjmp</tt> with the same <tt>jmp_buf</tt> structure causes the process to go "back in time" to the state stored in said structure. The way this is useful is that, when going back in time, we tweak the return value of the <tt>setjmp</tt> call so we can actually run a second (or third or more) path as if nothing had happened.<br /><br />Let's see an example:<pre>#include &lt;setjmp.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />static jmp_buf buf;<br /><br />static void<br />myfunc(void)<br />{<br />   printf("In the function.n");<br /><br />   ... do some complex stuff ...<br /><br />   /* Go back in time: restore the execution context of setjmp<br />    * but make the call return 1 instead of 0. */<br />   longjmp(buf, 1);<br /><br />   printf("Not reached.n");<br />}<br /><br />int<br />main(void) {<br />   if (setjmp(buf) == 0) {<br />       /* Try block. */<br />       printf("Trying some function that may throw.n");<br />       myfunc();<br />       printf("Not reached.n");<br />   } else {<br />       /* Catch block. */<br />       printf("Exception caught.n");<br />   }<br />   return EXIT_SUCCESS;<br />}</pre>The example above shows the following when executed:<pre>Trying some function that may throw.<br />In the function.<br />Exception caught.</pre>So, what happened above? The code starts by calling <tt>setjmp</tt> to record the execution state and the call returns 0, which causes the first part of the conditional to run. You can think of this clause as the "try" part of an exception-based code. At some point during the execution of <tt>myfunc</tt>, an error is detected and is "thrown" by a call to <tt>longjmp</tt> and a value of 1. This causes the process to go back to the execution of <tt>setjmp</tt> but this time the call returns 1, which causes the second part of the conditional to run. You can think of this second clause as the "catch" part of an exception-based code.<div><br /></div><div>It is still unclear to me what the "execution context" stored in <tt>jmp_buf</tt> is: the documentation does not explain what kind of resources are correctly unwinded when the call to <tt>longjmp</tt> is made... which makes me wary of using this technique for exception-like handling purposes. Oh, and this is even less clear in the context of C++ code and, e.g. calls to destructors. Would be nice to expand the description of these APIs in the manual pages.</div>
