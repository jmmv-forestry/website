---
layout: post
title: "Readability: Do not abuse classes as global state"
date: 2013-07-08 12:00:00 -0400
categories: readability
julipedia: 2013/07/readability-do-not-abuse-classes-as.html
excerpt_separator: </p>
---
<p>You know that passing state around different functions by using global variables is bad: it results in spaghetti code, it introduces side-effects to your functions and, well, is just bad practice.  Then: don't make the same mistake when using classes.</p> <p>The form this manifests in code is by having a particular class method (not necessarily the constructor!) initializing a member field and later having other unrelated methods querying the attribute "out of the blue".</p> <p>Consider the following code in which we have the definition of a class to represent a real-world object and a caller test method:</p> <pre>class Table(object):<br /><br />    def __init__(self, database, label):<br />        self._database = db<br />        self._label = label<br /><br />        self.depth = None<br />        self.height = None<br />        self.width = None<br /><br />    def query_dimensions(self):<br />        self.depth = self._database.get(self._label, 'depth')<br />        self.height = self._database.get(self._label, 'height')<br />        self.width = self._database.get(self._label, 'width')<br /><br />    def volume(self):<br />        <b>self.query_dimensions()</b><br />        return self.depth * self.height * self.width<br /><br />def test():<br />    table = Table('foo', Database.connect())<br />    <b>table.query_dimensions()</b><br />    print table.depth, table.height, table.width<br />    print table.volume()</pre> <p>Yes, I've seen something similar in production.  No, this is not good.  There are many problems with this design, but let's focus on the one that is the point of this article.</p> <p>The specific problem I want to highlight is in the <tt>query_dimensions()</tt> method: such method is abusing the local attributes as input parameters and is also storing its various return values into attributes.  The fact that this method is public is even worse, as illustrated by the need to call it before being able to access public attributes.</p> <p>Conceptually, a function to retrieve values from a database should be receiving the database and the object identifier as parameters, and return the results of the query.  We want the function to not use global state and instead look like this:</p> <pre>@staticmethod<br />def query_dimensions(database, label):<br />    depth = database.get(label, 'depth')<br />    height = database.get(label, 'height')<br />    width = database.get(label, 'width')<br />    return depth, height, width</pre> <p>Note that this function has no hidden dependencies: all data read or written is accessed via input parameters or returned via return values.</p> <p>Now, plugging this into our previous class allows us to "fix" the <tt>volume()</tt> method to not rely on updating the local variables in a magic manner.  However, having changed the function this way exposes that the various public attributes cannot now be accessed from outside.  We need to rewrite the code quite heavily:</p> <pre>class Table(object):<br /><br />    def __init__(self, database, label):<br />        self._database = db<br />        self._label = label<br /><br />        self._depth = None<br />        self._height = None<br />        self._width = None<br /><br />    @staticmethod<br />    def _query_dimensions(database, label):<br />        depth = database.get(label, 'depth')<br />        height = database.get(label, 'height')<br />        width = database.get(label, 'width')<br />        return depth, height, width<br /><br />    def depth(self):<br />        if self._depth is None:<br />            self._depth, self._height, self._width = (<br />                self._query_dimensions(self._database,<br />                                       self._label)<br />        return self._depth<br /><br />    def height(self):<br />        if self._height is None:<br />            self._depth, self._height, self._width = (<br />                self._query_dimensions(self._database,<br />                                       self._label)<br />        return self._height<br /><br />    def width(self):<br />        if self._width is None:<br />            self._depth, self._height, self._width = (<br />                self._query_dimensions(self._database,<br />                                       self._label)<br />        return self._width<br /><br />    def volume(self):<br />        return self.depth() * self.height() * self.width()<br /><br />def test():<br />    table = Table('foo', Database.connect())<br />    print table.depth(), table.height(), table.width()<br />    print table.volume()</pre> <p>This new code is certainly much longer than the original code.  However, this updated version is easier to follow because the points at which attributes get updated have been made explicit.  Also, this offers better encapsulation by avoiding the caller to know how to recompute internal values.</p> <p>To summarize: don't use attributes for data that only need to be passed around methods.  Attempt to make your methods independent from the instance, or at least think about them this way so that you realize what dependencies they have.</p>
