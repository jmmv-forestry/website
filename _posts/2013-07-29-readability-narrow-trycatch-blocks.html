---
layout: post
title: "Readability: Narrow try/catch blocks"
date: 2013-07-29 12:00:00 -0400
categories: readability
julipedia: 2013/07/readability-narrow-trycatch-blocks.html
excerpt: Post imported from The Julipedia; excerpt not available.
---
<p><tt>Try</tt>/<tt>catch</tt> blocks (or <tt>try</tt>/<tt>except</tt>, or whatever they happen to be named in your favorite language) are the mechanism by which you capture exceptions raised by a chunk of code in a controlled manner.  Within that chunk of code, it does not matter which line throws the exception: any exception specified in the <tt>catch</tt> statement will be captured, and it is "impossible" to know at that point where it originated.</p> <p>Consider this piece of code:</p> <pre>try:<br />    input_data = None<br />    with open("list.txt", "r") as input_file:<br />        input_data = load_data_from_file(input_file)<br /><br />    connection = Database.connect()<br /><br />    data_for_import = prepare_data_for_import(input_data)<br /><br />    for entry in data_for_input:<br />        connection.add(entry)<br />except DatabaseError, e:<br />    logging.error('Failed to connect to the database')<br />    raise e<br />except IOError, e:<br />    logging.error("Failed to open the input file')<br />    raise e</pre> <p>Can you tell if there is anything wrong in this code?  Maybe, maybe not, because there is not enough context to tell with certainty.</p> <p>Let's look at the exception handler for <tt>DatabaseError</tt>: if you check the error message, the error says <tt>"Failed to <b>connect</b> to the database"</tt>.  Is that right?  The chunk of code protected by the <tt>try</tt> block has two calls to the database code: one via <tt>Database.connect()</tt> and another via <tt>connection.add(entry)</tt>.  So, which is it: a) is the message bogus because it applies to exceptions that arise when connecting <em>and</em> when writing to the database, b) does the write to the database raise a different exception that we are not handling, or c) does the call to <tt>connection.add(entry)</tt> not raise any exception (unlikely) and therefore our <tt>try</tt> block is too wide?</p> <p>Let's also look at the exception handler for <tt>IOError</tt>, which shows the same issue as the previous one.  The error message talks about failures to <strong>open</strong> the input file, but not about reading from it.  Maybe that is the right thing to do in some piece of code, but most likely it isn't.</p> <p>My <i>weak</i> guideline &mdash; weak because I only apply it counted times&mdash; to clarify such a piece of code and make it more robust is to make <tt>try</tt>/<tt>catch</tt> blocks as narrow as possible.  This indicates to the reader that you are aware that the contained piece of code raises the mentioned exceptions and no more, and that the code outside of the block does not raise such exceptions.</p> <p>Following this rule, the above code snippet would look like this:</p> <pre>input_data = None<br />try:<br />    with open("list.txt", "r") as input_file:<br />        input_data = load_data_from_file(input_file)<br />except IOError, e:<br />    logging.error("Failed to load the input file')<br />    raise e<br />assert input_data is not None<br /><br />connection = None<br />try:<br />    connection = Database.connect()<br />except DatabaseError, e:<br />    logging.error('Failed to connect to the database')<br />    raise e<br />assert connection is not None<br /><br />data_for_import = prepare_data_for_import(input_data)<br /><br />for entry in data_for_input:<br />    connection.add(entry)</pre> <p>Now it is obvious that <tt>connection.add</tt> most likely needs some kind of exception handling, as a write to an external system can always fail in some way.  At this point, we are forced to decide whether we want to surround the single statement in a <tt>try</tt>/<tt>catch</tt> block, or instead we want to do so for the loop as a whole.  This will depend on whether we want a fail-fast approach or a more greedy algorithm.</p> <p>You may have noticed by now that the above looks pretty much like a poor man's replacement for explicit error handling, and you may be right.  Exceptions may sounds like a nice idea and, depending on the language, cannot be avoided... but getting them right and implementing accurate error handling with them is just <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx">really hard</a>.  Keep your code simple.</p>
