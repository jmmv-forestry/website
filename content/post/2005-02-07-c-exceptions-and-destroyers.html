---
title: "C++: Exceptions and destroyers"
date: 2005-02-07 08:23:00 -0500
julipedia: 2005/02/c-exceptions-and-destroyers.html
slug: c-exceptions-and-destroyers
---
<p>If you use exceptions to signal errors in C++, you should be really careful when throwing an exception from inside a class' destroyer function, because you can easily cause an abort trap. Consider the following code:</p>  <pre>struct test {<br />  ~test(void) {<br />      throw int(0);<br />  }<br />};<br /><br />int main(void) {<br />  try {<br />      test t;<br />      throw int(1);<br />  } catch (int e) {<br />  } catch (...) {<br />  }<br /><br />  return 0;<br />}</pre><p></p>  <p>Trivial, isn't it?  Well, now compile it and run it: you will get a "nice" core dump.  However, if you disable the <tt>throw</tt> statement inside <tt>~test</tt>, the problem will go away.  The problem will also disappear if you move <tt>test</tt>'s instantiation outside the try block.</p>  <p>But... why does this happen?  When the <tt>int(1)</tt> exception is thrown, the <tt>t</tt> object has to be destroyed before it can be handled, because its scope has to be cleaned (see how it's placed inside the try block). When this happens, the destroyer function throws a new exception (while we were handling another one), which could produce an infinite loop. Voila, you've got the abort trap.</p>  <p>So be aware when throwing an exception from a destroyer. Simply put, you must make sure that they will not generate exceptions; you have to handle any possible failure from within them.</p><p class="mobile-post"></p>
