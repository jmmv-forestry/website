---
title: "Error handling in Lua: the Kyua approach"
date: 2011-01-14 03:04:00 -0500
categories:
  - "c++"
  - "kyua"
  - "lua"
julipedia: 2011/01/error-handling-in-lua-kyua-approach.html
slug: error-handling-in-lua-kyua-approach
---
About a week ago, I detailed the different approaches I encountered to <a href="{{< relref "2011-01-07-error-handling-in-lua.html" >}}">deal with errors raised by the Lua C API</a>. Later, I announced the <a href="{{< relref "2011-01-08-c-interface-to-lua.html" >}}">new C++ interface for Lua</a> implemented within <a href="http://code.google.com/p/kyua/">Kyua</a>. And today, I would like to talk about the specific mechanism I implemented in this library to deal with the Lua errors.<br /><br />The first thing to keep in mind is that the whole purpose of Lua in the context of Kyua is to parse configuration files. This is an infrequent operation, so <i>high performance does not matter</i>: it is more valuable to me to be able to write robust algorithms fast than to have them run at optimal speed. The other key point to consider is that I want Kyua to be able to use prebuilt Lua libraries, which are built as C binaries.<br /><br />The approach I took is to wrap every single unsafe Lua C API call in a "thin" (FSVO thin depending on the case) wrapper that gets called by <tt>lua_pcall</tt>. Anything that runs inside the wrapper is safe to Lua errors, as they are caught and safely reported to the caller.<br /><br />Lets examine how this works by taking a look at an example: the wrapping of <tt>lua_getglobal</tt>. We have the following code (copy pasted from the <a href="http://code.google.com/p/kyua/source/browse/trunk/kyua-cli/utils/lua/wrap.cpp?spec=svn39&r=39">utils/lua/wrap.cpp</a> file but hand-edited for publishing here):<pre>static int<br />protected_getglobal(lua_State* state)<br />{<br />    lua_getglobal(state, lua_tostring(state, -1));<br />    return 1;<br />}<br /><br />void<br />lua::state::get_global(const std::string& name)<br />{<br />    lua_pushcfunction(_pimpl->lua_state, protected_getglobal);<br />    lua_pushstring(_pimpl->lua_state, name.c_str());<br />    if (lua_pcall(_pimpl->lua_state, 1, 1, 0) != 0)<br />        throw lua::api_error::from_stack(_pimpl->lua_state,<br />            "lua_getglobal");<br />}</pre>The <tt>state::get_global</tt> method is my public wrapper for the <tt>lua_getglobal</tt> Lua C API call. This wrapper first prepares the Lua stack by pushing the address of the C function to call and its parameters and then issues a <tt>lua_pcall</tt> call that executes the C function in a Lua protected environment.<br /><br />In this case, the argument preparation for <tt>protected_getglobal</tt> is trivial because the <tt>lua_getglobal</tt> call does not require access to any preexisting values on the Lua stack. Things get much trickier when that happens as in the case of the <tt>lua_getglobal</tt> wrapper. I'll leave understanding how to do this as an exercise to the reader (but you can cheat by looking at <a href="http://code.google.com/p/kyua/source/browse/trunk/kyua-cli/utils/lua/wrap.cpp?spec=svn39&r=39#154">line 154</a>).<br /><br />Anyway. The above looks all very nice and safe and the <a href="http://code.google.com/p/kyua/source/browse/trunk/kyua-cli/utils/lua/wrap_test.cpp?spec=svn39&r=39#112">tests for the state::get_global function</a>, even the ones that intentionally cause a failure, all work fine. So we are good, right? <i>Nope!</i> Unfortunately, the code above is not fully safe to Lua errors.<br /><br />In order to prepare the <tt>lua_pcall</tt> execution, the code must push values on the stack. As it turns out, both <tt>lua_pushcfunction</tt> and <tt>lua_pushstring</tt> <i>can</i> fail if they run out of memory (OOM). Such failure would of course be captured inside a protected environment... but we have a little chicken'n'egg problem here. That said, OOM failures are rare so I'm going to leverage this fact and not worry about it.  (Note to self: install a <tt>lua_atpanic</tt> handler to complain loudly if that ever happens.)<br /><br /><b>Addendum</b>: Bundling Lua within my program and building it as a C++ binary with exception reporting enabled in <tt>luaconf.h</tt> would magically solve all my issues. I know. But I don't fancy the idea of bundling the library into my source tree for a variety of reasons.
