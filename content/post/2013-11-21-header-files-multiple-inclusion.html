---
title: "Header files: Multiple-inclusion protection"
date: 2013-11-21 12:00:00 -0500
categories:
  - "header-files"
julipedia: 2013/11/header-files-multiple-inclusion.html
excerpt_separator: </p>
---
<p>Let's start the series with something simple: the basic structure of header files and why and how to protect against multiple inclusion.</p> <p><b>The rule</b></p> <p>The basic use of header files is to provide symbol declarations for functions and globals.  Because multiple declarations of a given symbol in a single translation unit are a syntax error, you have to defensively structure your header files to not redefine anything in case they are included multiple times.</p> <p>Keep in mind that you just cannot prevent header files from being included more than once unless you were to forbid header files themselves from including other header files... and doing that would be suboptimal at best as we shall see in a future post on self-containment.</p> <p>Just follow this pattern and encapsulate the whole contents of the <i>whole</i> header file within a guard:</p> <pre>#if !defined(PROJECT_MODULE_H)<br />#define PROJECT_MODULE_H<br /><br />... all header file contents go here ...<br /><br />#endif  /* !defined(PROJECT_MODULE_H) */</pre> <p>Easy, but there are two important details to keep in mind:</p> <p>The first is <b>to properly scope the guard names</b>.  These names must be unique within your project and within any project that may ever include them.  Therefore, it is good practice to always prefix your guard names with the name of your project and follow them by the name of the module.</p> <p>The second is <b>to not be clever</b>.  Compilers <i>expect</i> the structure above in order to apply optimizations against multiple inclusions of a single file.  If you break the pattern, you can unknowingly incur higher build times.  For example, <a href="http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html">see GCC's documentation on this topic</a> for details.</p> <p><b>The exception</b></p> <p>As with any rule there is an exception: not all header files can safely be included more than once.  If a header file defines a static symbol or helper function, you have to ensure that it is not pulled in from more than one place.</p> <p>Yes, the compiler would detect this on its own but, for readability purposes, your header file should explicitly state this fact.  Use this other pattern instead:</p> <pre>#if defined(PROJECT_MODULE_H)<br />#error "Must only be included once and only from .c files"<br />#endif<br />#define PROJECT_MODULE_H<br /><br />... all header file contents go here ...</pre> <p>But when can this happen?  Very rarely, really.  A specific case of the above would be a header file providing helper functions for testing, both their definitions and their implementation.  Theoretically, you could split the two into a traditional header file and a source file, compile them separately and link them together with each test program you write.  However, doing so may complicate your build unnecessarily.  (Ab)using a single header file can make things easier to handle.  <a href="https://code.google.com/p/kyua/source/browse/utils/sqlite/test_utils.hpp?spec=svnc8d23d1736823ac35f56a15f87fe453c12469205&r=9b5b6a1e82594e30d04e684bdf8612ad417c9209">See this test_utils.hpp example.</a></p>
