---
title: "Modifying the environment from scripts"
date: 2005-04-11 14:29:00 -0400
julipedia: 2005/04/modifying-environment-from-scripts.html
slug: modifying-environment-from-scripts
---
<p>Two days ago, a friend of mine was trying to modify the environment (the <tt>CLASSPATH</tt>) from within a shell script. Her intention was to run the script and then start working with Java on the same shell were the script was run. This didn't work. In order to explain why, I'm going to review the three different ways to run scripts and how they are related to the current environment.</p>  <p>Let's create a sample file, named <tt>foo.sh</tt> and stored in the home directory.  Its purpose will be to modify a variable and create a function:</p>  <pre>FOO_VAR=hello; export FOO_VAR<br />foo_func() {<br />  echo "Hello, world!"<br />}</pre><p></p>  <p>Now, before running it, ensure that the environment is clean (i.e., that the variable is empty and that the function is undefined. To make things easier, just open a new terminal.</p>  <p>It's time to run the script.  The first attempt will be to execute it using the shell interpreter explicitly:</p>  <pre>$ sh ~/foo.sh<br />$ echo ${FOO_VAR}<br />$ foo_func<br />ksh: foo_func: not found<br />$</pre><p></p>  <p>Oops!  It didn't work.  Why?  I hear.  Well.  When you run the script this way, you are launching a shell <i>sub-process</i> in which the script is executed. Therefore, when the shell exits — which happens upon file's EOF — the modifications to the environment are lost.</p>  <p>Let's try it in a different way, this time using a <i>shell bang</i>.  Edit the foo.sh script and add <tt>#!/bin/sh</tt> as the very first line (there can't be any spaces before this).  Then, give it execute permissions and try again:</p>  <pre>$ vi ~/foo.sh<br />... add #!/bin/sh at the beginning...<br />$ chmod +x ~/foo.sh<br />$ ~/foo.sh<br />$ echo ${FOO_VAR}<br />$ foo_func<br />ksh: foo_func: not found<br />$</pre><p></p>  <p>What? It didn't work either. This case is equivalent to the previous one; the only difference is that the OS creates the sub-shell for us: it sees the magic shell bang ("<tt>#!</tt>", or "<tt>#! /</tt>" in some old OSes) at the beginning of the file and uses the program name given there to run the script.</p>  <p>The last possibility — and only solution to the problem — is to run the script in <i>the same shell process</i> as we are working, so it will modify the current environment. Think of it as if you were manually typing the contents of the file in the window you are working on.</p>  <p>How is this done? Just call the program with a single dot before its name, separated by an space. This magic keyword tells the shell to "source" the given file:</p>  <pre>$ . ~/foo.sh<br />$ echo ${FOO_VAR}<br />hello<br />$ foo_func<br />Hello, world!<span style="font-family:sans-serif;"><br /></span></pre>It worked. Hope it's clear now! PS: The export keyword I used in the sample file is used to tell the shell to propagate the given shell variables to further sub-shells, <i>not</i> parent ones. If you don't use it, then the variable is private to the current instance of the interpreter and won't be visible from anywhere else.<p class="mobile-post"></p>
