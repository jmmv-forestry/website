---
title: "ATF's error handling in C"
date: 2008-02-24 12:52:00 -0500
categories:
  - "atf"
  - "c"
julipedia: 2008/02/atfs-error-handling-in-c.html
excerpt_separator: </p>
---
One of the things I miss a lot when writing the C-only code bits of ATF is an easy way to raise and handle errors.  In C++, the normal control flow of the execution is not disturbed by error handling because any part of the code is free to notify error conditions by means of exceptions.  Unfortunately, C has no such mechanism, so errors must be handled explicitly.<br /><br />At the very beginning I just made functions return integers indicating error codes and reusing the standard error codes of the C library. However, that turned out to be too simple for my needs and, depending on the return value of a function (not an integer), was not easily applicable.<br /><br />What I ended up doing was defining a new type, <tt>atf_error_t</tt>, which must be returned by all functions that can raise errors.  This type is a pointer to a memory region that can vary in contents (and size) depending on the error raised by the code.  For example, if the error comes from libc, I mux the original error code and an informative message into the error type so that the original, non-mangled information is available to the caller; or, if the error is caused by the user's misuse of the application, I simply return a string that contains the reason for the failure.  The error structure contains a type field that the receiver can query to know which specific information is available and, based on that, cast down the structure to the specific type that contains detailed information.  Yes, this is very similar to how you work with exceptions.<br /><br />In the case of no errors, a null pointer is returned.  This way checking for an error condition is just a simple pointer check, which is no more expensive than an integer check.  However, handling error conditions is more costly, but given that these are rare, it is certainly not a problem.<br /><br />What I don't like too much of this approach is that any other return value must be returned as an output parameter, which makes things a bit confusing.  Furthermore, robust code ends up cluttered with error checks all around given that virtually any call to the library can produce an error somewhere.  This, together with the lack of RAII modeling, complicates error handling a lot.  But I can't think of any other way that could be simpler but, at the same time, as flexible as this one.  Ideas? :P<br /><br />More details are available in the <a href="http://mtn-host.prjek.net/viewmtn/atf/revision/file/1dc8887d38a3001e5465217991b054a4dab3a253/atf-c/error.h">atf-c/error.h</a> and <a href="http://mtn-host.prjek.net/viewmtn/atf/revision/file/1dc8887d38a3001e5465217991b054a4dab3a253/atf-c/error.c">atf-c/error.c</a> files.
