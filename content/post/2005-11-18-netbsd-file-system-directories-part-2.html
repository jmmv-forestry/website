---
title: "NetBSD: File system directories, part 2"
date: 2005-11-18 10:17:00 -0500
julipedia: 2005/11/netbsd-file-system-directories-part-2.html
slug: netbsd-file-system-directories-part-2
---
In the <a href="http://julipedia.blogspot.com/2005/11/netbsd-file-system-directories-part-1.html">first part</a>, we saw what a directory is and gave some fuzzy ideas on how it is implemented. Let's now outline the most common operations run on directories: <tt>lookup</tt> and <tt>readdir</tt>.<br /><br />The <tt>lookup</tt> operation receives a path component name (a string without slashes) and returns the node pointed to by this name within the directory, assuming, of course, that the entry exists. Otherwise, it tells the caller that the entry is missing or incorrect (i.e., not a directory). This operation takes advantage of the <a href="http://netbsd.gw.com/cgi-bin/man-cgi?namecache++NetBSD-current">name cache</a> because it must be fast; keep in mind that lookups are executed extremely often.<br /><br />The implementation of the <tt>lookup</tt> operation, however, is very complex. It is cluttered by a weird locking protocol and has a lot of special cases. These include <i>access advices</i>, a technique used to tell the operation what kind of lookup is happening: a creation, a removal, a rename or a simple lookup. UFS uses these to locate empty holes in the directory while looking for an entry, among other things. tmpfs uses it to avoid two lookups for the same file on some operations, such as the creation.<br /><br />On the other hand, we have the <tt>readdir</tt> operation, the one used to read the contents of a directory. This operation is conceptually simple, as all it has to do is read as much entries as possible from the offset given to it. These entries are returned in a standard format, described in <a href="http://netbsd.gw.com/cgi-bin/man-cgi?getdents++NetBSD-current">getdents(2)</a>.<br /><br />However, there is a tricky thing in <tt>readdir</tt>: the <i>cookies</i>. They are used by the NFS server to map directory entries to offsets within it so that further lookups can be done in a more efficient manner. For each entry returned by <tt>readdir</tt>, a cookie is also returned that specifies its physical offset inside the directory. A further call to this operation using the cookie's value could restart the read at the point where the entry lives.<br /><br />It is also interesting to note that some file systems return fake cookies because they do not have physical offsets within them &mdash; in other words, they are not stored on disk. This happens in, e.g., tmpfs or kernfs.<br /><br />Post suggested by Pavel Cahyna.
