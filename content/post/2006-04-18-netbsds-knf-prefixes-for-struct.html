---
title: "NetBSD's KNF: Prefixes for struct members"
date: 2006-04-18 14:59:00 -0400
julipedia: 2006/04/netbsds-knf-prefixes-for-struct.html
excerpt_separator: </p>
slug: netbsds-knf-prefixes-for-struct
---
The NetBSD coding <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/share/misc/style?rev=HEAD">style guide</a>, also known as Kernel Normal Form (KNF), suggests to prefix a <tt>struct</tt>'s members with a string that represents the structure they belong to.  For example: all <tt>struct tmpfs_node</tt> members are prefixed by <tt>tn_</tt> and all <tt>struct wsdisplay_softc</tt> members start with <tt>sc_</tt>.  But why there is such a rule?  After all, the style guide does not mention the reasons behind this.<br /><br />The first reason is clarity.  When accessing a structure instance, whose name may be <i>anything</i>, seeing a known prefix in the attribute helps in determining the variable's type.  For example, if I see <tt>foo-&gt;sc_flags</tt>, I know that <tt>foo</tt> is an instance of some <tt>softc</tt> structure.  As happens with all clarity guidelines, this is subjective.<br /><br />But there is another reason, which is not more technical.  Using unprefixed names pollutes the global namespace, a specially dangerous situation if the structure belongs to a public header.  Why?  Because of the preprocessor &mdash; that thing that should have never existed &mdash; or more specifically, the <i>macros</i> provided by it.<br /><br />Let's see an example: consider a <tt>foo.h</tt> file that does this:<pre>#ifndef _FOO_H_<br />#define _FOO_H_<br /><br />struct foo {<br />    int locked;<br />};<br /><br />#endif</pre>And now take the following innocent piece of code:<pre>#define locked 1<br />#include &lt;foo.h&gt;</pre>Any attempt to access <tt>struct foo</tt>'s <tt>locked</tt> member will fail later on because of the macro definition.  Prefixing the variable mitigates this situation.
