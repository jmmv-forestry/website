---
title: "Writing portable code"
date: 2004-09-19 12:38:00 -0400
julipedia: 2004/09/writing-portable-code.html
excerpt_separator: </p>
slug: writing-portable-code
---
<p>Portability problems can be seen from two points of view: the operating system and the architecture. Depending on the kind of application you are developing, you may hit these problems. An example of OS-portability can be the use of a specific hardware subsystem through kernel facilities; on the other hand, an example of architecture-portability can be the direct use of assembly code.</p>  <p>Often, you will be aware that a chunk of your code is not portable; for example, when accessing Linux's ACPI subsystem, you can be sure that that part of the code <i>won't</i> work outside Linux.</p>  <p>Some people will do an extra research effort and see how other systems do what they need, and will add the right code to make their program portable. Unfortunately, many people opts to keep the code as is within the program.; that is, it gets compiled unconditionally, thus causing build failures on any other OS. And a wrong desing at this point will make your code <i>unreadable</i> when adding portability workarounds.</p>  <p>In this situation, you can mitigate the problem by isolating the unportable code, even if you won't be implementing support for other platforms. This way, anyone who builds the package will quickly notice why it fails, and he may be able to provide a better patch with less hassle. How to do it is up to you: either create a source file for each platform you want to support, use preprocessor conditionals or use inheritance in an OOP language. Whichever case you choose, keep scalability in mind: adding support for another OS/architecture should be easy (I'm referring to the code structure, not to how easy is to port the feature).</p>  <p>Resuming the previous ACPI example, you could organize your code by using a file per OS, like in: <tt>acpi-linux.c</tt>, <tt>acpi-netbsd.c</tt>, etc.  Or you could do something like:</p>  <pre>/* Prototypes for portability functions defined below. */<br />static void _acpi_init(void);<br /><br />/* Public functions that are called from other .c files. */<br />void<br />acpi_init(void) {<br />   ...<br />   _acpi_init();<br />   ...<br />}<br /><br />#ifdef __linux__<br />/* Inclusion of Linux-specific headers */<br />/* Private functions to use Linux's ACPI */<br />static void<br />_acpi_init(void) { ... }<br />#elifdef __NetBSD__<br />/* Inclusion of NetBSD-specific headers */<br />/* Private functions to use NetBSD's ACPI */<br />static void<br />_acpi_init(void) { ... }<br />#else<br />#  error "Sorry, this code has not been ported yet."<br />#endif</pre><p></p>  <p>As you can see, the "generic" code is kept simple: it calls the system specific function and does any other common stuff; no conditionals are inserted there to handle OS details. Moreover pay special attention to the <tt>#error</tt> directive: it will tell the preson building your software why it failed, and won't lead him to confusion.</p>  <p></p>These comments come from lots of portability issues I've hit while making some programs work under NetBSD; fortunately, I'm not using anything else than i386. Hope you find these suggestions helpful and apply them to your code; they'd make the task of packagers a bit easier. Ah, and remember: the world is not Linux/i386 only!<p></p><p class="mobile-post"></p>
