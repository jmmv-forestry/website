---
title: "Dynamic open of libpthread considered harmful"
date: 2004-11-14 15:21:00 -0500
julipedia: 2004/11/dynamic-open-of-libpthread-considered.html
excerpt_separator: </p>
---
<p>Here goes another portability issue I've met multiple times while packaging software for <a href="http://www.netbsd.org/">NetBSD</a> 2.x, where libpthread has some restrictions that other systems don't seem to have. Simply put, a non-threaded program cannot become threaded at run time, because, if it does, you get a nice "Abort trap". But, how can this happen?</p>  <p>Suppose you have an application that is not linked against libpthread, neither directly nor indirectly (through required libraries). The initialization code used to set up this program doesn't need to care about threads, because it's assumed that they won't be used. Hence you have a non-threaded program. Note that the important part here is <i>the initialization code used to setup the program</i>, not whether the program uses calls to <tt>pthread_*</tt> functions or not.</p>  <p>Now imagine that this non-thread program loads a shared object (be it a library or a plugin) using <tt>dlopen(3)</tt>. This is not by itself a problem. The funny part comes when the shared object being opened is linked against libpthread; that is, threaded code. There you have the "Abort trap". You have loaded threaded code into a non-threaded application. Here is a little example for you to play with:</p>  <pre>#include &lt;dlfcn.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;  <p>int<br />main(void)<br />{<br />   void *handle;<br /></p><p>    (void)printf("Loading libpthread.son");<br />   handle = dlopen("libpthread.so", RTLD_LAZY);<br />   (void)printf("libpthread.so loadedn");<br />   dlclose(handle);</p><p>    return EXIT_SUCCESS;<br />}</p></pre><p></p>  <p>Can this problem be worked around? Sure. It's as simple as linking the non-threaded application against libpthread (even if it won't make any use of threads), because this library will override the initialization code used to set up the program. I've done this, for example, in the <tt>gtk-query-immodules-2.0</tt> utility that comes with <a href="http://www.gtk.org/">GTK+</a>, because some plugins loaded by it are threaded.</p>  <p>Considering the previous example, doing: <tt>cc test.c ; ./a.out</tt> will produce a crash.  But <tt>cc -lpthread test.c ; ./a.out</tt> will not.  And even <tt>cc test.c ; LD_PRELOAD=/usr/lib/libpthread.so ./a.out</tt> will work too.  Remember?  It's the initialization code that matters, not the amount of threads used by the code.</p>  <p>Now, before thinking this is a bug in NetBSD, let me say that this was a design decision in the libpthread library. I don't remember the rationale behind it, but I guess you should be able to find it <a href="http://www.google.com/">Google</a>ing a bit ;-)</p><p class="mobile-post"></p>
