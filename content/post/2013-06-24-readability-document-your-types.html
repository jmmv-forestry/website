---
title: "Readability: Document your types"
date: 2013-06-24 12:00:00 -0400
categories:
  - "python"
  - "readability"
julipedia: 2013/06/readability-document-your-types.html
excerpt_separator: </p>
slug: readability-document-your-types
---
<p>Wow.  The previous post titled <a href="/2013/06/self-interview-after-leaving-netbsd.html">Self-interview after leaving the NetBSD board</a> has turned out to be, by far, the most popular article in this blog.  The feedback so far has been positive and I owe all of you a follow-up post.  However, writing such post will take a while and content must keep flowing.  So let's get back to the <a href="http://julipedia.meroh.net/search/label/readability">readability series</a> for now.</p> <hr /> <p>In dynamically-typed languages<sup>1</sup>, variable and function definitions do not state the type of their arguments.  This is quite convenient when writing code, but results in very hard to read "stuff" later on.  Consider this snippet:</p> <pre>def compute_balances(accounts):<br />    """Calculates the balances of a set of accounts.<br /><br />    Args:<br />        accounts: Accounts for which to compute the balances.<br /><br />    Returns:<br />        The balances for every account.<br />    """<br />    balances = new_balances()<br />    for account in accounts:<br />        balances[account.name] += account.balance<br />    return balances</pre> <p>Now, this example is certainly trivial and I'm writing it to illustrate the docstring text more than the code itself.  That said: what is the type of <tt>accounts</tt>?  What is the return type of the function?</p> <p>When you write code in one of these typeless languages, <i>document the types of your function arguments and return values</i>, and do so in the most specific way you can &mdash; possibly using the native type syntax of the language you are using.  The specific style I use is:</p> <pre>def compute_balances(accounts):<br />    """Calculates the balances of a set of accounts.<br /><br />    Args:<br />        accounts: <b>frozenset(Account).</b>  Accounts for which to<br />            compute the balances.<br /><br />    Returns:<br />        <b>dict(str, Balance).</b>  The balances for every account.<br />    """<br />    balances = new_balances()<br />    for account in accounts:<br />        balances[account.name] += account.balance<br />    return balances</pre> <p>While this may seem like unnecessary boilerplate, and it may also seem like such comments will likely get out of sync with the code later on, these details become invaluably helpful later on when reading code written by others.</p> <p>Of course, I'd suggest you to choose a strictly-typed language in the first place, but that'd just be calling for a flamewar ;-)  A similar piece of code in C++ would look like this:</p> <pre>/// Calculates the balances of a set of accounts.<br />///<br />/// param accounts Accounts for which to compute the balances.<br />///<br />/// return The balances for every account.<br />std::map&lt; std::string, balance &gt;<br />compute_balances(const std::set&lt; account &gt;&amp; accounts):<br />    std::map&lt; std::string, balance &gt; balances = new_balances();<br />    for (auto account : accounts) {<br />        balances[account.name] += account.balance<br />    }<br />    return balances<br />}</pre> <p>The types in this case are required by the compiler but also provide useful information to the user of this function.  Even more, if we ran this through Doxygen, the generated documentation would also automatically detail the types of the inputs and the return value.</p> <p>To recap: <i>always write docstrings for your functions and annotate them with specific type information for all inputs and outputs</i>.</p> <hr /> <p><sup>1</sup> That's not strictly true.  Some strongly-typed languages, such as Haskell, also have typeless definitions of variables and functions.  The same suggestions given here also apply to such languages as well, even when the types can be automatically inferred.</p>
