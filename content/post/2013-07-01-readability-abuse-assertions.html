---
title: "Readability: Abuse assertions"
date: 2013-07-01 12:00:00 -0400
categories:
  - "readability"
julipedia: 2013/07/readability-abuse-assertions.html
excerpt_separator: </p>
---
<p>Assertions are statements to ensure that a particular condition or state holds true at a certain point in the execution of a program.  These checks are usually only performed in debug builds, which means that you must ensure that the expressions in the assertions are side-effect free.</p> <p>Because assertions are only validated in debug builds, you can abuse them to make your code more readable without impacting performance and <a href="/2013/06/readability-avoid-comments.html">without having to write a comment</a>.  Every time you write a line in which you assume a particular machine state that is not clearly implied by the code immediately preceding the new line, write an assertion.</p> <p>Let's look at a real world example derived from Kyua's code.  Consider the following extremely-simplified function which implements the <tt>help</tt> command:</p> <pre>def help_command(args):<br />    if len(args) == 0:<br />        show_general_help()<br />    else:<br />        show_command_help(args[0])</pre> <p>With this code alone, try to answer these questions: <i>"What happens if <tt>args</tt>, which apparently is a subset of the arguments to the program, has more than 1 item?  Are the additional arguments ignored and thus we have a bug in the code, or has the <tt>args</tt> vector been pre-sanitized by the caller to not have extra arguments?"</i> Well, you can't answer this question because there is nothing in the code to tell you what the case is.</p> <p>If I now show you the caller to the function, you can get an idea of what the expectation is:</p> <pre>def main(args):<br />    commands = {}<br />    commands['help'] = cli.Command(min_args=0, <b>max_args=1</b>,<br />                                   hook=help_command)<br />    ...<br />    cli.dispatch(commands, args)</pre> <p>Aha!  There happens to be an auxiliary library that processes the command line and dispatches calls to the various subcommands based on a declarative interface.  This declarative interface specifies what the maximum number of arguments to the command can be, so our function above for <tt>help_command</tt> was correct: it was handling all possible lengths of the input <tt>args</tt> vector.</p> <p>But that's just too much work to figure out a relative simple piece of code.  A piece of code needs to be self-explanatory with as little external context as possible.  We can do this with assertions.</p> <p>The first thing you can do is state the precondition to the function as an assertion:</p> <pre>def help_command(args):<br />    <b>assert len(args) &lt;= 1</b><br />    if len(args) == 0:<br />        show_general_help()<br />    else:<br />        show_command_help(args[0])</pre> <p>This does the trick: now, without any external context, you can tell that the <tt>args</tt> vector is supposed to be empty or have a single element, and the code below clearly handles both cases.</p> <p>However, I argue that this is still suboptimal.  What is the complementary condition of <tt>len(args) == 0</tt>?  Easy: <tt>len(args) &gt; 0</tt>.  Then, if that's the case, how can the <tt>else</tt> path be looking at the first argument only and not the rest?  Didn't someone overlook the rest of the arguments, possibly implying that the input data is not fully validated?  This would be a legitimate question if the function was much longer than it is and reading it all was hard.  Therefore, we would do this instead:</p> <pre>def help_command(args):<br />    if len(args) == 0:<br />        show_general_help()<br />    else:<br />        <b>assert len(args) == 1</b><br />        show_command_help(args[0])</pre> <p>Or this:</p> <pre>def help_command(args):<br />    if len(args) == 0:<br />        show_general_help()<br />    <b>elif len(args) == 1:</b><br />        show_command_help(args[0])<br />    <b>else:</b><br />        <b>assert False, 'args not properly sanitized by caller'</b></pre> <p>Both of these alternatives clearly enumerate all branches of a conditional, which makes the function easier to reason about.  We will get to this in a future post.</p> <p>Before concluding, let's outline some cases in which you should really be writing assertions:</p> <ul><li>Preconditions and postconditions.</li><li>Assumptions about state that has been validated elsewhere in the code, possibly far away from the current code.</li><li>Complementary conditions in conditionals where not all possible values of a type are being inspected.</li><li>Unreachable code paths.</li></ul>
