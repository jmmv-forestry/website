---
title: "Injecting C++ functions into Lua"
date: 2011-01-17 11:09:00 -0500
categories:
  - "c++"
  - "kyua"
  - "lua"
julipedia: 2011/01/injecting-c-functions-into-lua.html
slug: injecting-c-functions-into-lua
---
The <a href="{{< relref "2011-01-08-c-interface-to-lua.html" >}}">C++ interface to Lua</a> implemented in <a href="http://code.google.com/p/kyua/">Kyua</a> exposes a <tt>lua::state</tt> class that wraps the lower-level <tt>lua_State*</tt> type. This class completely hides the internal C type of Lua to ensure that all calls that affect the state go through the <tt>lua::state</tt> class.<br /><br />Things get a bit messy when we want to inject native functions into the Lua environment. These functions follow the prototype represented by the <tt>lua_CFunction</tt> type:<blockquote><tt>typedef int (*lua_CFunction)(lua_State*);</tt></blockquote>Now, let's consider this code:<pre>int<br />awesome_native_function(lua_State* state)<br />{<br />    // Uh, we have access to s, so we bypass the lua::state!<br />    ... do something nasty ...<br /><br />    // Oh, and we can throw an exception here...<br />    //with bad consequences.<br />}<br /><br />void<br />setup(...)<br />{<br />    lua::state state;<br />    state.push_c_function(awesome_native_function);<br />    state.set_global("myfunc");<br />    ... run some script ...<br />}</pre>The fact that we must pass a <tt>lua_CFunction</tt> prototype to the <tt>lua_pushcfunction</tt> object means that such function must have access to the raw <tt>lua_State*</tt> pointer... which we want to avoid.<br /><br />What we really want is the caller code to define a function such as:<blockquote><tt>typedef int (*cxx_function)(lua::state&)</tt></blockquote>In an ideal world, the <tt>lua::state</tt> class would implement a <tt>push_cxx_function</tt> that took a <tt>cxx_function</tt>, generated a thin C wrapper and injected such generated wrapper into Lua.  Unfortunately, we are not in an ideal world: C++ does not have high-order functions and thus the "generate a wrapper function" part of the previous proposal does not really work.<br /><br />What we can do instead, though, is to make the creation of C wrappers for these C++ functions trivial. And this is what <a href="http://code.google.com/p/kyua/source/detail?r=42">r42</a> did.  The approach I took is similar to this overly-simplified (and broken) example:<pre>template&lt; cxx_function Function &gt;<br />int<br />wrap_cxx_function(lua_State* state)<br />{<br />    try {<br />        lua::state state_wrapper(state);<br />        return Function(state_wrapper);<br />    } catch (...) {<br />        luaL_error(state, "Geez, don't go into C's land!");<br />    }<br />}</pre>This template wrapper takes a <tt>cxx_function</tt> object and generates a corresponding C function <i>at compile time</i>. This wrapper function ensures that C++ state does not propagate into the C world, as that often has catastrophical consequences. (Due to language limitations, the input function must have external linkage.  So no, it cannot be static.)<br /><br />As a result, we can rewrite our original snippet as:<pre>int<br />awesome_native_function(lua::state& state)<br />{<br />    // See, we cannot access lua_State* now.<br /><br />    ... do something ...<br />    throw std::runtime_error("And we can even do this!");<br />}<br /><br />void<br />setup(...)<br />{<br />    lua::state state;<br />    state.push_c_function(<br />        wrap_cxx_function< awesome_native_function >);<br />    state.set_global("myfunc");<br />    ... run some script ...<br />}</pre>Neat? I think so, but maybe not so much. I'm pretty sure there are cooler ways of achieving the above purpose in a cleaner way, but this one works nicely and has few overhead.
