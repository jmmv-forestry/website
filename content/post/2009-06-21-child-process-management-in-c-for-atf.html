---
title: "Child-process management in C for ATF"
date: 2009-06-21 13:40:00 -0400
categories:
  - "atf"
  - "c"
julipedia: 2009/06/child-process-management-in-c-for-atf.html
excerpt_separator: </p>
slug: child-process-management-in-c-for-atf
---
Let's face it: spawning child processes in Unix is a "mess". Yes, the interfaces involved (fork, wait, pipe) are really elegant and easy to understand, but every single time you need to spawn a new child process to, later on, execute a random command, you have to write quite a bunch of error-prone code to cope with it. If you have ever used any other programming language with higher-level abstraction layers — just check Python's subprocess.Popen — you surely understand what I mean.<div><br /><div><div>The current code in ATF has many places were child processes have to be spawned. I recently had to add yet another case of this, and... enough was enough. Since then, I've been working on a C API to spawn child processes from within ATF's internals and just pushed it to the repository. It's still fairly incomplete, but with minor tweaks, it'll keep all the dirty details of process management contained in a single, one-day-to-be-portable module.</div><div><br /></div><div>The interface tries to mimic the one that was designed on my Boost.Process Summer of Code project, but in C, which is quite painful. The main idea is to have a fork function to which you pass the subroutine you want to run on the child, the behavior you want for the stdout stream and the behavior you want for the stderr steam. These behaviors can be any of capture (aka create pipes for IPC communcations), silence (aka redirect to /dev/null), redirect to file descriptor and redirect to file. For simplicity, I've omitted stdin. With all this information, the fork function returns you an opaque structure representing the child, from which you can obtain the IPC channels if you requested them and on which you can wait for finalization.</div><div><br /></div><div>Here is a little example, with tons of details such as error handling or resource finalization removed for simplicity. The code below would spawn "/bin/ls" and store its output in two files named ls.out and ls.err:</div><pre>static<br />atf_error_t<br />run_ls(const void *v)<br />{<br /> system("/bin/ls");<br /> return atf_no_error();<br />}<br /><br />static<br />void<br />some_function(...)<br />{<br /> atf_process_stream_t outsb, errsb;<br /> atf_process_child_t child;<br /> atf_process_status_t status;<br /><br /> atf_process_status_init_redirect_path(&amp;outsb, "ls.out");<br /> atf_process_status_init_redirect_path(&amp;errsb, "ls.err");<br /><br /> atf_process_fork(&amp;child, run_ls, &amp;outsb, &amp;errsb, NULL);<br /> ... yeah, here comes the concurrency! ...<br /> atf_process_child_wait(&amp;child, &amp;status);<br /><br /> if (atf_process_status_exited(&amp;status))<br />     printf("Exit: %dn", atf_process_status_exitstatus(&amp;status));<br /> else<br />     printf("Error!");<br />}</pre><div>Yeah, quite verbose, huh? Well, it's the price to pay to simulate namespaces and similar other things in C. I'm not too happy with the interface yet, though, because I've already encountered a few gotchas when trying to convert some of the existing old fork calls to the new module. But, should you want to check the whole mess, <a href="http://mtn-host.prjek.net/viewmtn/atf/revision/info/3ba2af4ab1cad67108c3fb1aea15e8e0168667ff">check out the corresponding revision</a>.</div></div></div>
