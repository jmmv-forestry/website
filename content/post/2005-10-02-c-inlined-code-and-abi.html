---
title: "C++: Inlined code and the ABI"
date: 2005-10-02 09:18:00 -0400
julipedia: 2005/10/c-inlined-code-and-abi.html
excerpt_separator: </p>
---
<p>There are many development libraries that provide inline functions (or macros) as part of their public API. This is often done for efficiency reasons, although some times it's done because developers don't know the consequences of doing such things (this last thing is just a guess, but it can perfectly happen). Providing such inlined functions breaks the whole idea of encapsulation and shared libraries. Let's see why.</p>  <p>Consider the following simple class:</p>  <pre>/* In foo.h. */<br />class foo {<br />   int m_value;  <p>public:<br />   int get_value(void) { return m_value; }<br />   void set_value(int v);<br />   /* ... */<br />};</p><p>/* In foo.c; this is _not_ inlined. */<br />void<br />foo::set_value(int v)<br />{<br />   m_value = v;<br />}</p></pre><p></p>  <p>Now imagine that this class belongs to a shared library, say <tt>libbar.so.1.0</tt>.  Given this, our Joe user does this in his code, which is perfectly legal:</p>  <pre>foo a;<br /><br />a.set_value(5);<br />/* ... do whatever with 'a' ... */<br />int b = a.get_value();</pre><p></p>  <p>When this code is compiled, the compiler replaces the call to <tt>foo::get_value()</tt> with the method's code, avoiding a function call, a return and all the stack set up; all the action takes place in the user's code, not in the library. Typically, getting a value from a structure means reading a concrete position of memory within it, described by its offset from the beginning. OTOH, the call to <tt>foo::set_value()</tt> is correctly made into a regular function call inside the shared library's text.</p>  <p>Some time later, the libbar developers decide to change the internal representation of the <tt>foo</tt> class for whatever reason. According to the encapsulation principle used in object oriented designs, they should be able to, after all. Let's suppose they add a new integer before the <tt>m_value</tt> field, called <tt>m_id</tt>. Unwillingly, the developers have just changed the ABI of their library and, if they don't take care to update the library's major number, seriuos problems will arise. But, why?</p>  <p>Our Joe user again sees a new release of libbar, say 1.1, so he rebuilds and updates it in his machine, replacing <tt>libbar.so.1.0</tt> with <tt>libbar.so.1.1</tt>; these two libraries typically share the same soname, <tt>libbar.so.1</tt>, because they are compatible in theory.  According to how shared libraries work, he oughtn't rebuild his application.</p>  <p>The <tt>set_value()</tt> call will continue to work correctly because the application will call the new function in the updated shared library. However, the execution of <tt>get_value()</tt> will be broken; oops! Remember the sample code shown above? It was compiled as an offset within the class, which is now different! This getter will return an incorrect value, no matter what he does. He'll be forced to rebuild his application to adjust to the new ABI.</p>  <p>Conclusion: be very careful when defining inlined methods and macros. If you need to fix a mistake or modify the internal representation of your code in the future, you will be unable to. Personally, I avoid inlined code in all public interfaces, despite this introduces a small performance degradation; however, they are perfectly fine for internal code.</p>  <p>It's a pity that careless C++ developers make so intensive use of such inlined code. BTW, note that although this has focused on C++, the same is true for, e.g., C99, which provides an <tt>inline</tt> keyword.</p>  <p><b>Edit (Oct 3rd)</b>: Based on <a href="http://www.livejournal.com/users/jmmv/44985.html?thread=43193#t43193">this reply</a>, I've removed some (really minor) references to templated code from the article; they certainly didn't belong here.</p><p class="mobile-post"></p>
