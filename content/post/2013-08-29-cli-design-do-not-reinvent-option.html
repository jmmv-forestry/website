---
title: "CLI design: Do not reinvent option parsing"
date: 2013-08-29 12:00:00 -0400
categories:
  - "cli-design"
julipedia: 2013/08/cli-design-do-not-reinvent-option.html
excerpt_separator: </p>
---
<p>In the <a href="/2013/08/cli-design-putting-flags-to-good-use.html">previous post</a>, we saw what good and bad use cases for flags in the interface of a command-line application are.  We talked about the theory, so it is now the time to talk about the implementation details.</p> <p>The point I want to make in this post is simple: <i>do <b>not</b> reinvent option parsing</i>.  Use the libraries provided by the platform you are targeting to implement the interface of your application: even if there is some little detail of the library that you don't agree with, consistency with the platform is lightyears better than a custom implementation that fails to handle some corner cases and/or behaves in an unexpected manner.</p> <p><b>Framework-less tools for Unix</b></p> <p>The interface that you use to implement option parsing in a console-based, framework-less application for Unix depends on the language you are using and the libraries you are targeting.  Let's take a look at a few specific examples:</p> <ul> <li><b>C</b>: If all you have access to (or want to depend on) is the standard C library, the only choice you have is to use the <tt>getopt(3)</tt> and <tt>getopt_long(3)</tt> library functions.  The former is a POSIX standard while the latter isn't but is widely available.  <b>Edit (based on email suggestion):</b> There also is <a href="http://www.gnu.org/software/autogen/autoopts.html">AutoOpts</a>, which is a powerful option parser and a documentation generator from the options descriptor.</li> <li><b>C++</b>: In this case, you can use the same interfaces as you use for C.  However, if you use the popular Boost libraries, you can use <a href="http://www.boost.org/doc/libs/1_54_0/doc/html/program_options.html">Boost.Program_options</a> for a native C++ interface.  Be aware that the semantics are slightly different, partly because this library is portable to Windows.</li> <li><b>Shell</b>: Use the <tt>getopts</tt> builtin function of the shell interpreter to handle option parsing.  Avoid using the external <tt>getopt(1)</tt> utility as it cannot handle whitespace in arguments properly.  Note that none of these two interfaces support processing long-style flags; if you want to deal with those, you probably need to implement your own parsing.  If you do, try to follow the interface of <tt>getopt_long</tt> as much as possible.</li> <li><b>Python</b>: Just use the <a href="http://docs.python.org/2/library/argparse.html#module-argparse">argparse module</a>.  <b>Edit (based on email suggestion):</b> Replaced optparse with argparse as the former is deprecated.</li> </ul> <p><b>Tools for GNOME</b></p> <p>If you are writing an application that integrates with the GNOME desktop environment, or an application that uses a subset of the libraries provided by this platform, use the <a href="https://developer.gnome.org/glib/2.30/glib-Commandline-option-parser.html">Commandline option parser</a> of Glib.  Note that Glib is not a graphical library, so you can even use it for your console-based utilities that don't need access to the graphics environment.</p> <p><b>Tools for KDE</b></p> <p>Similarly to the GNOME applications, the KDE platform provides its own option parsing library for C++.  Use the <a href="http://api.kde.org/4.x-api/kdelibs-apidocs/kdecore/html/classKCmdLineArgs.html">KCmdLineArgs class</a> to perform your option-parsing tasks.</p> <hr /> <p>What do you think?  Did I miss some important and standard mechanism to parse options?  If so, which one?</p>
