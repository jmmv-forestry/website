---
title: "Header files: Self-containment"
date: 2013-11-25 12:00:00 -0500
categories:
  - "header-files"
julipedia: 2013/11/header-files-self-containment.html
excerpt_separator: </p>
slug: header-files-self-containment
---
<p><b>The rule</b></p> <p>The mere fact of <i>including</i> a given header file, without including any other beforehand, should not be enough of a reason for the <i>build</i> to break.  This means that the header file should be self-contained, and for this to be the case, such header file has to pull in any dependencies that it <b>explicitly requires</b> (and no more).</p> <p>Interestingly, note that this does <i>not</i> mean that a header file must include <i>everything</i> it may ever need to be fully <i>usable</i>.</p> <p><b>The example</b></p> <p>Let's take a look at an example to give some meaning to the above.  Consider a <tt>thelog</tt> library that implements functionality to write to a log file and provides various supporting data types.  This library is composed of the following files:</p> <ul><li><tt>thelog/delta.h</tt>: Defines the <tt>struct delta</tt> type.  Includes no other header file.</li><li><tt>thelog/log_entry.h</tt>: Defines the <tt>struct log_entry</tt> type and helper functions.</li><li><tt>thelog/timestamp.h</tt>: Defines the <tt>struct timestamp</tt> type.  Includes no other header file.</li><li><tt>thelog/user.h</tt>: Defines the <tt>struct user</tt> type.  Includes no other header file.</li></ul> <p>With these types in mind, the <tt>thelog/log_entry.h</tt> file could look like this:</p> <pre>#if !defined(THELOG_LOG_ENTRY_H)<br />#define THELOG_LOG_ENTRY_H<br /><br />#include &lt;thelog/user.h&gt;<br />#include &lt;thelog/timestamp.h&gt;<br /><br />struct log_entry {<br />    <b>struct user</b> caller;<br />    <b>struct timestamp</b> start_time;<br />    <b>struct timestamp</b> end_time;<br />};<br /><br />struct delta;<br /><b>struct delta *</b>log_entry_length(const struct log_entry*);<br /><br />#endif  /* !defined(THELOG_LOG_ENTRY_H) */</pre> <p>Take a close look at the highlighted types and compare those to the included header files.  Notice anything?  We are only including header files for 2 out of the 3 referenced types and using a forward declaration for the third.  Why is that?</p> <p>Simple.  The <tt>struct user</tt> and <tt>struct timestamp</tt> data types are instantiated in this header file and determine the size of the log entry.  In order to ever instantiate such a structure, you must know what all of its dependencies are, so for the build to work, you have to pull in their definitions which conveniently live in separate header files.</p> <p>On the other hand, the prototype definition of <tt>log_entry_length</tt> does not require any knowledge of the <i>specifics</i> of its return type: knowing only that the type exists is enough to yield a valid function declaration, and thus a forward declaration is <i>sufficient</i> to fulfill the build requirements.</p> <p>So what's up with that <tt>struct delta</tt>?  If the user ever calls the <tt>log_entry_length</tt> function, he will have to include <tt>thelog/delta.h</tt> on his own as a hidden dependency anyway and thus encapsulation is broken!  <b>False.</b>  The user will only need to include this other header file if he wishes to mess around with the <i>internals</i> of the type itself.  And if he ever does that, then the user code gains a <i>direct</i> dependency on this other data type and thus the user code should be explicitly including the other header file anyway.  See "<a href="https://code.google.com/p/include-what-you-use/wiki/WhyIWYU">Why Include What You Use?</a>" for some details on this.</p> <p><b>The exception</b></p> <p>The exception?  There <i>should</i> be none (in my opinion), but they exist.  Traditionally, and unfortunately, many files under <tt>sys/</tt> are <i>not</i> self-contained.  This has been a common source of <a href="http://bikeshed.org/">bikesheds</a> in NetBSD (and possibly elsewhere) although I'm having trouble now finding a reference.</p> <p>When you use symbols in any of these special header files, make sure to check the relevant manual pages to see which dependent header files you require.  And... beware that these dependencies vary across operating systems, so you are in for a portability nightmare.</p> <p><b>The trick</b></p> <p>There is a very simple trick to routinely ensure your header files are self-contained.</p> <p>In the past, I used very complex approaches to validate this which ranged from building one-liner source files with the inclusion of the desired header file to plugging these into ATF-based test cases.  The boilerplate required to perform this validation was astonishing and a waste of time.  As it turns out, there is a much simpler approach &mdash; and, to tell you the truth, writing about this little trick is what triggered <a href="http://julipedia.meroh.net/search/label/header-files">this whole series on header files</a>!  <p>So what is it?  Easy: <i>include the header file for the module you are implementing at the very beginning of your module</i>.  That's it!  No more no less.  For example: in the implementation of a module <tt>resources.c</tt>, make sure to include its corresponding <tt>resources.h</tt> before anything else.  By doing this, you have one test case for every header file to ensure that the header file is self-contained.  If any of your header files is not self-contained, the build will fail as soon as you compile the offending module.</p> <p>In the case of header-only modules, you can achieve this same effect by following this trick in the test program corresponding the header file.  Actually, if you have one test program per every module (which you <i>do</i> have, right?) you should apply the trick mentioned here both to the <tt>.c</tt> implementation and to the test program.</p>
