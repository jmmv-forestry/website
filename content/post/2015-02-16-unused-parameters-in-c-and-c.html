---
title: "Unused parameters in C and C++"
date: 2015-02-16 17:40:00 -0500
categories:
  - "c"
  - "c++"
julipedia: 2015/02/unused-parameters-in-c-and-c.html
slug: unused-parameters-in-c-and-c
---
<p>Today I would like to dive into the topic of <i>unused parameters</i> in C and C++: why they may happen and how to properly deal with them&mdash;because smart compilers will warn you about their presence should you enable <tt>-Wunused-parameter</tt> or <tt>-Wextra</tt>, and even error out if you are brave enough to use <tt>-Werror</tt>.</p> <h4>Why may unused parameters appear?</h4> <p>You would think that unused parameters should never exist: if the parameter is not necessary as an input, it should not be there in the first place!  That's a pretty good argument, but it does not hold when polymorphism enters the picture: if you want to have different implementations of a single API, such API will have to provide, on input, a superset of all the data required by all the possible implementations.</p> <p>The obvious case of the above is having an abstract method implemented by more than one subclass (which you can think of as a function pointer within a <tt>struct</tt> in the case of C).  In this scenario, the caller of this abstract method may be handling a generic condition but the various specific implementations may or may not use all the input data.</p> <h4>Our example</h4> <p>An example taken straight from Kyua is the <tt>compute_result</tt> method, whose purpose is <i>to determine the status of a test case after termination based on the outputs of the test program</i>, including: the program's exit code, its standard output, its standard error, and files that may be left in the transient work directory.  The signature of this abstract method looks like this:</p> <pre style="background: #ffeeee; padding: 5px;">virtual model::test_result <b>compute_result</b>(<br />    const optional< process::status >& <b>status</b>,<br />    const fs::path& <b>work_directory</b>,<br />    const fs::path& <b>stdout_path</b>,<br />    const fs::path& <b>stderr_path</b>) const = 0;</pre> <p>Kyua implements this interface three times: one for plain test programs, one for ATF-based test programs, and one for TAP-compliant test programs.  This interface receives all test-related post-termination data as inputs so that the different implementations can examine <i>any</i> parts (possibly not all) they require to compute the result.</p> <p>In concrete terms: the plain interface only looks at the exit status; the ATF interface looks both at the exit status and at a file that is left in the work directory; and the TAP interface looks both at the exit status and the standard output of the program.</p> <p>When you face an scenario like this where you have a generic method, it is clear that your code will end up with functions that receive some parameters that they do not <i>need to</i> use.  This is alright.  However, as obvious as it may be to you, the compiler does not know that and therefore assumes a coding error, warning you along the way.  Not helpful.</p> <h4>Two simple but unsuitable alternatives</h4> <p>A first mechanism around this, which only works in C++, is to omit the parameter <i>name</i> in the function definition.  Unfortunately, doing so means you cannot reference the parameter by name any longer in your documentation and, furthermore, this solution does not work for C.</p> <p>A second mechanism is to introduce side-effect free statements in your code of the form <tt>(void)unused_argument_name;</tt>.  Doing this is extremely ugly (for starters, you have to remember to keep such statements in sync with reality) and I fear is not guaranteed to silence the compiler&mdash;because, well, the compiler will spot a spurious statement and could warn about it as well.</p> <p>Because these two solutions are suboptimal, I am not going to invest any more time on them.  Fortunately, there is a third alternative.</p> <h4>Tagging unused parameters with compiler attributes</h4> <p>The third and best mechanism around this is to explicitly tag the unused parameters with the <tt>__attribute__((unused))</tt> GCC extension as follows:</p> <pre style="background: #ffeeee; padding: 5px;">model::test_result <b>compute_result</b>(<br />    const optional< process::status >& <b>status</b>,<br />    const fs::path& <b>work_directory __attribute__((unused))</b>,<br />    const fs::path& <b>stdout_path __attribute__((unused))</b>,<br />    const fs::path& <b>stderr_path __attribute__((unused))</b>) const;</pre> <p>But this, as shown, is not portable.  How can you make it so?</p> <h4>Making the code portable</h4> <p>If you want your code to work portably across compilers, then you have to go a bit further because the <tt>__attribute__</tt> decorators are not standard.  The most basic abstraction macro you'd think of is as follows:</p> <pre style="background: #ffeeee; padding: 5px;">#define UTILS_UNUSED __attribute__((unused))</pre> <p>... which you could parameterize as:</p> <pre style="background: #ffeeee; padding: 5px;">#define UTILS_UNUSED @ATTRIBUTE_UNUSED@</pre> <p>... so that your <tt>configure.ac</tt> script could determine what the right mechanism to mark a value as unused in your platform is and perform the replacement.  This is not trivial, so take a look at Kyua's <a href="https://github.com/jmmv/kyua/blob/master/m4/compiler-features.m4">compiler-features.m4</a> for <tt>configure.ac</tt> to get some ideas.</p> <p>Such a simple macro then lets you write:</p> <pre style="background: #ffeeee; padding: 5px;">model::test_result <b>compute_result</b>(<br />    const optional< process::status >& <b>status</b>,<br />    const fs::path& <b>work_directory UTILS_UNUSED</b>,<br />    const fs::path& <b>stdout_path UTILS_UNUSED</b>,<br />    const fs::path& <b>stderr_path UTILS_UNUSED</b>) const;</pre> <p>... which gets us most of the way there, but not fully.</p> <h4>Going further</h4> <p>The <tt>UTILS_UNUSED</tt> macro shown above lets the compiler know that the argument may be unused and that this is acceptable.  Unfortunately, if an argument is marked as unused but it is <i>actually used</i>, the compiler will not tell you about it.  Such a thing can happen once you modify the code months down the road and forget to modify the function signature.  If this happens, it is a recipe for obscure issues, if only because you will confuse other programmers when they read the code and cannot really understand the intent behind the attribute declaration.</p> <p>My trick to fix this, which I've been using successfully for various years, is to define a macro that <i>also wraps the argument name</i>; say: <tt>UTILS_UNUSED_PARAM(stdout_path)</tt>.  This macro does two things: first, it abstracts the definition of the attribute so that <tt>configure</tt> may strip it out if the attribute is not supported by the underlying compiler; and, second and more importantly, <b>it <i>renames</i> the given argument by prefixing it with the <tt>unused_</tt> string</b>.  This renaming is where the beauty lies: the name change will forbid you from using the parameter via its given name and thus, whenever you have to start using the parameter, you will very well know to remove the macro from the function definition.  Has worked every single time since!</p> <p>Here is how the macro looks like (straight from <a href="https://github.com/jmmv/kyua/blob/master/utils/defs.hpp.in">Kyua's defs.hpp.in file</a>):</p> <pre style="background: #ffeeee; padding: 5px;">#define UTILS_UNUSED @ATTRIBUTE_UNUSED@<br />#define UTILS_UNUSED_PARAM(name) unused_ ## name UTILS_UNUSED</pre> <p>And here is how the macro would be used in our example above:</p> <pre style="background: #ffeeee; padding: 5px;">/// This is a Doxygen-style docstring.<br />///<br />/// Note how, in this comment, we must refer to our unused<br />/// parameters via their modified name.  This also spills to our<br />/// public API documentation, making it crystal-clear to the<br />/// reader that these parameters are not used.  Because we are<br />/// documenting here a specific implementation of the API and not<br />/// its abstract signature, it is reasonable to tell such details<br />/// to the user.<br />///<br />/// param <b>status</b> Status of the exit process.<br />/// param <b>unused_work_directory</b> An unused parameter!<br />/// param <b>unused_stdout_path</b> Another unused parameter!<br />/// param <b>unused_stderr_path</b> Yet another unused parameter!<br />///<br />/// return The computed test result.<br />model::test_result <b>compute_result</b>(<br />    const optional< process::status >& <b>status</b>,<br />    const fs::path& <b>UTILS_UNUSED_PARAM(work_directory)</b>,<br />    const fs::path& <b>UTILS_UNUSED_PARAM(stdout_path)</b>,<br />    const fs::path& <b>UTILS_UNUSED_PARAM(stderr_path)</b>) const;</pre> <h4>What about Doxygen?</h4> <p>As I just mentioned Doxygen above, there is one extra trick to get our macros working during the documentation extraction phase.  Because Doxygen does not implement a full-blown C/C++ parser&mdash;although I wish it did, and nowadays this is relatively easy thanks to LLVM!&mdash;you have to tell Doxygen how to interpret the macro.  Do so with the following code to the <tt>Doxyfile</tt> control file:</p> <pre style="background: #ffeeee; padding: 5px;">PREDEFINED  = "UTILS_UNUSED="<br />PREDEFINED += "UTILS_UNUSED_PARAM(name)=unused_ ## name"</pre> <p>So, what about you?  Do you keep your code warning-free by applying similar techniques?</p>
